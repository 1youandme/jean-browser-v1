use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;
use chrono::{DateTime, Utc, Duration};
use tokio::sync::RwLock;
use std::sync::Arc;
use regex::Regex;

use crate::models::{JeanMemory, JeanAction, JeanPermission, User};
use crate::commands::{CommandResult, DatabasePool};
use crate::jean_permissions::JeanPermissions;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JeanRequest {
    pub user_id: Uuid,
    pub session_id: Option<String>,
    pub message: String,
    pub context: Option<serde_json::Value>,
    pub attachments: Option<Vec<JeanAttachment>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JeanAttachment {
    pub r#type: String, // image, file, url
    pub content: String,
    pub metadata: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JeanResponse {
    pub message: String,
    pub actions: Vec<JeanAction>,
    pub requires_confirmation: bool,
    pub context_updates: Option<serde_json::Value>,
    pub memory_entries: Option<Vec<JeanMemory>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct JeanAction {
    pub id: Uuid,
    pub action_type: String,
    pub description: String,
    pub data: serde_json::Value,
    pub requires_confirmation: bool,
    pub estimated_impact: String,
    pub category: ActionCategory,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ActionCategory {
    Browser,
    FileSystem,
    System,
    Ecommerce,
    Proxy,
    Development,
}
    System,
    Ecommerce,
    Communication,
    Security,
}

#[derive(Debug, Clone)]
pub struct JeanCore {
    db: Arc<DatabasePool>,
    memory_store: Arc<RwLock<MemoryStore>>,
    permission_manager: Arc<PermissionManager>,
    action_executor: Arc<ActionExecutor>,
    ai_client: Arc<AIClient>,
}

impl JeanCore {
    pub fn new(db: Arc<DatabasePool>) -> Self {
        Self {
            db: db.clone(),
            memory_store: Arc::new(RwLock::new(MemoryStore::new(db.clone()))),
            permission_manager: Arc::new(PermissionManager::new(db.clone())),
            action_executor: Arc::new(ActionExecutor::new()),
            ai_client: Arc::new(AIClient::new()),
        }
    }

    pub async fn process_request(&self, request: JeanRequest) -> Result<JeanResponse, String> {
        // 1. Load user context and preferences
        let user_context = self.load_user_context(request.user_id).await?;
        
        // 2. Retrieve relevant memories
        let relevant_memories = self.memory_store.read().await
            .retrieve_context_memories(&request.message, request.user_id).await?;
        
        // 3. Check for any immediate permission requirements
        let action_analysis = self.analyze_requested_actions(&request).await?;
        
        // 4. Process with AI
        let ai_response = self.ai_client.process_message(
            &request.message,
            &user_context,
            &relevant_memories,
            &action_analysis
        ).await?;
        
        // 5. Parse AI response into structured actions
        let actions = self.parse_ai_actions(ai_response.actions, request.user_id).await?;
        
        // 6. Check permissions for each action
        let (confirmed_actions, pending_actions) = self.check_action_permissions(
            actions,
            request.user_id
        ).await?;
        
        // 7. Store memory of this interaction
        self.store_interaction_memory(&request, &ai_response).await?;
        
        // 8. Execute auto-approved actions
        let execution_results = self.execute_approved_actions(confirmed_actions).await?;
        
        // 9. Build response
        Ok(JeanResponse {
            message: ai_response.message,
            actions: pending_actions,
            requires_confirmation: !pending_actions.is_empty(),
            context_updates: ai_response.context_updates,
            memory_entries: Some(relevant_memories),
        })
    }

    async fn load_user_context(&self, user_id: Uuid) -> Result<UserContext, String> {
        let mut conn = self.db.acquire().await
            .map_err(|e| format!("Database error: {}", e))?;

        // Get user preferences
        let preferences = sqlx::query_as!(
            JeanPreferences,
            r#"
            SELECT * FROM jean_preferences WHERE user_id = $1
            "#,
            user_id
        )
        .fetch_optional(&mut *conn)
        .await
        .map_err(|e| format!("Failed to load preferences: {}", e))?;

        // Get active permissions
        let permissions = sqlx::query_as!(
            JeanPermission,
            r#"
            SELECT * FROM jean_permissions 
            WHERE user_id = $1 AND is_active = TRUE AND expires_at > NOW()
            "#,
            user_id
        )
        .fetch_all(&mut *conn)
        .await
        .map_err(|e| format!("Failed to load permissions: {}", e))?;

        // Get current session context
        let session_context = if let Some(session_id) = &request.session_id {
            self.get_session_context(user_id, session_id).await?
        } else {
            None
        };

        Ok(UserContext {
            user_id,
            preferences: preferences.unwrap_or_default(),
            permissions,
            session_context,
        })
    }

    async fn analyze_requested_actions(&self, request: &JeanRequest) -> Result<ActionAnalysis, String> {
        // Use AI to analyze what actions might be needed
        let keywords = self.extract_action_keywords(&request.message);
        
        Ok(ActionAnalysis {
            potential_actions: keywords,
            risk_level: self.assess_risk_level(&keywords),
            suggested_permissions: self.suggest_permissions(&keywords),
        })
    }

    async fn parse_ai_actions(
        &self,
        ai_actions: Vec<serde_json::Value>,
        user_id: Uuid
    ) -> Result<Vec<JeanAction>, String> {
        let mut actions = Vec::new();
        
        for action_data in ai_actions {
            let action: JeanAction = serde_json::from_value(action_data)
                .map_err(|e| format!("Failed to parse AI action: {}", e))?;
            
            actions.push(action);
        }
        
        Ok(actions)
    }

    async fn check_action_permissions(
        &self,
        actions: Vec<JeanAction>,
        user_id: Uuid
    ) -> Result<(Vec<JeanAction>, Vec<JeanAction>), String> {
        let mut confirmed = Vec::new();
        let mut pending = Vec::new();
        
        for action in actions {
            let has_permission = self.permission_manager
                .check_permission(user_id, &action.action_type, &action.data).await?;
            
            if has_permission || !action.requires_confirmation {
                confirmed.push(action);
            } else {
                pending.push(action);
            }
        }
        
        Ok((confirmed, pending))
    }

    async fn execute_approved_actions(&self, actions: Vec<JeanAction>) -> Result<Vec<ActionResult>, String> {
        let mut results = Vec::new();
        
        for action in actions {
            let result = self.action_executor.execute(action).await?;
            results.push(result);
        }
        
        Ok(results)
    }

    async fn store_interaction_memory(
        &self,
        request: &JeanRequest,
        response: &AIResponse
    ) -> Result<(), String> {
        let memory = JeanMemory {
            id: Uuid::new_v4(),
            user_id: request.user_id,
            memory_type: "conversation".to_string(),
            content: serde_json::json!({
                "request": request.message,
                "response": response.message,
                "session_id": request.session_id
            }),
            context_tags: vec!["conversation".to_string()],
            session_id: request.session_id.clone(),
            is_private: false,
            is_archived: false,
            created_at: Utc::now(),
            updated_at: Utc::now(),
        };
        
        self.memory_store.write().await.store_memory(memory).await?;
        Ok(())
    }

    fn extract_action_keywords(&self, message: &str) -> Vec<String> {
        let message_lower = message.to_lowercase();
        let mut keywords = Vec::new();
        
        // File system keywords
        if message_lower.contains("delete") || message_lower.contains("remove") {
            keywords.push("file_delete".to_string());
        }
        if message_lower.contains("copy") || message_lower.contains("move") {
            keywords.push("file_operation".to_string());
        }
        
        // Browser keywords
        if message_lower.contains("open tab") || message_lower.contains("new tab") {
            keywords.push("browser_tab".to_string());
        }
        if message_lower.contains("navigate") || message_lower.contains("go to") {
            keywords.push("browser_navigate".to_string());
        }
        
        // System keywords
        if message_lower.contains("restart") || message_lower.contains("docker") {
            keywords.push("system_operation".to_string());
        }
        
        // E-commerce keywords
        if message_lower.contains("buy") || message_lower.contains("purchase") {
            keywords.push("financial_transaction".to_string());
        }
        
        keywords
    }

    fn assess_risk_level(&self, keywords: &[String]) -> RiskLevel {
        for keyword in keywords {
            match keyword.as_str() {
                "file_delete" | "system_operation" | "financial_transaction" => {
                    return RiskLevel::High;
                }
                "file_operation" | "browser_tab" => {
                    return RiskLevel::Medium;
                }
                _ => continue,
            }
        }
        RiskLevel::Low
    }

    fn suggest_permissions(&self, keywords: &[String]) -> Vec<String> {
        let mut suggestions = Vec::new();
        
        for keyword in keywords {
            match keyword.as_str() {
                "file_delete" => suggestions.push("file_management".to_string()),
                "system_operation" => suggestions.push("system_administration".to_string()),
                "financial_transaction" => suggestions.push("purchasing".to_string()),
                _ => continue,
            }
        }
        
        suggestions
    }

    async fn get_session_context(
        &self,
        user_id: Uuid,
        session_id: &str
    ) -> Result<Option<SessionContext>, String> {
        let mut conn = self.db.acquire().await
            .map_err(|e| format!("Database error: {}", e))?;

        let session = sqlx::query_as!(
            JeanSession,
            r#"
            SELECT * FROM jean_sessions 
            WHERE user_id = $1 AND session_id = $2 AND expires_at > NOW()
            "#,
            user_id,
            session_id
        )
        .fetch_optional(&mut *conn)
        .await
        .map_err(|e| format!("Failed to load session: {}", e))?;

        Ok(session.map(|s| SessionContext {
            session_id: s.session_id,
            context: s.context,
            active_strips: s.active_strips,
            current_workspace: s.current_workspace,
        }))
    }
}

// Supporting structures

#[derive(Debug, Clone)]
pub struct UserContext {
    pub user_id: Uuid,
    pub preferences: JeanPreferences,
    pub permissions: Vec<JeanPermission>,
    pub session_context: Option<SessionContext>,
}

#[derive(Debug, Clone)]
pub struct SessionContext {
    pub session_id: String,
    pub context: serde_json::Value,
    pub active_strips: serde_json::Value,
    pub current_workspace: Option<Uuid>,
}

#[derive(Debug, Clone)]
pub struct ActionAnalysis {
    pub potential_actions: Vec<String>,
    pub risk_level: RiskLevel,
    pub suggested_permissions: Vec<String>,
}

#[derive(Debug, Clone)]
pub enum RiskLevel {
    Low,
    Medium,
    High,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AIResponse {
    pub message: String,
    pub actions: Vec<serde_json::Value>,
    pub context_updates: Option<serde_json::Value>,
}

#[derive(Debug, Clone)]
pub struct ActionResult {
    pub action_id: Uuid,
    pub success: bool,
    pub result_data: Option<serde_json::Value>,
    pub error_message: Option<String>,
}

// Supporting services

pub struct MemoryStore {
    db: Arc<DatabasePool>,
}

impl MemoryStore {
    pub fn new(db: Arc<DatabasePool>) -> Self {
        Self { db }
    }

    pub async fn store_memory(&self, memory: JeanMemory) -> Result<(), String> {
        let mut conn = self.db.acquire().await
            .map_err(|e| format!("Database error: {}", e))?;

        sqlx::query!(
            r#"
            INSERT INTO jean_memory (
                id, user_id, memory_type, content, context_tags, 
                session_id, is_private, is_archived, created_at, updated_at
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
            "#,
            memory.id,
            memory.user_id,
            memory.memory_type,
            memory.content,
            &memory.context_tags,
            memory.session_id,
            memory.is_private,
            memory.is_archived,
            memory.created_at,
            memory.updated_at
        )
        .execute(&mut *conn)
        .await
        .map_err(|e| format!("Failed to store memory: {}", e))?;

        Ok(())
    }

    pub async fn retrieve_context_memories(
        &self,
        query: &str,
        user_id: Uuid
    ) -> Result<Vec<JeanMemory>, String> {
        let mut conn = self.db.acquire().await
            .map_err(|e| format!("Database error: {}", e))?;

        // Simple keyword-based retrieval for now
        // In production, this would use vector similarity search
        let memories = sqlx::query_as!(
            JeanMemory,
            r#"
            SELECT * FROM jean_memory 
            WHERE user_id = $1 AND memory_type = 'conversation'
            ORDER BY created_at DESC
            LIMIT 10
            "#,
            user_id
        )
        .fetch_all(&mut *conn)
        .await
        .map_err(|e| format!("Failed to retrieve memories: {}", e))?;

        Ok(memories)
    }
}

pub struct PermissionManager {
    db: Arc<DatabasePool>,
}

impl PermissionManager {
    pub fn new(db: Arc<DatabasePool>) -> Self {
        Self { db }
    }

    pub async fn check_permission(
        &self,
        user_id: Uuid,
        action_type: &str,
        action_data: &serde_json::Value
    ) -> Result<bool, String> {
        let mut conn = self.db.acquire().await
            .map_err(|e| format!("Database error: {}", e))?;

        // Check for explicit permission
        let permission = sqlx::query_as!(
            JeanPermission,
            r#"
            SELECT * FROM jean_permissions 
            WHERE user_id = $1 AND action_type = $2 
            AND is_active = TRUE AND expires_at > NOW()
            LIMIT 1
            "#,
            user_id,
            action_type
        )
        .fetch_optional(&mut *conn)
        .await
        .map_err(|e| format!("Failed to check permission: {}", e))?;

        if let Some(perm) = permission {
            // Check usage limits
            if let Some(max_usage) = perm.max_usage {
                if perm.usage_count >= max_usage {
                    return Ok(false);
                }
            }
            
            // Check financial limits
            if let Some(max_amount) = perm.max_amount {
                if let Some(amount) = action_data.get("amount") {
                    let amount_val: f64 = amount.as_f64().unwrap_or(0.0);
                    if amount_val > max_amount {
                        return Ok(false);
                    }
                }
            }
            
            Ok(true)
        } else {
            // No explicit permission found, check if action is allowed by default
            Ok(self.is_action_allowed_by_default(action_type))
        }
    }

    fn is_action_allowed_by_default(&self, action_type: &str) -> bool {
        match action_type {
            "browser_tab" | "browser_navigate" | "file_read" => true,
            _ => false,
        }
    }
}

pub struct ActionExecutor {
    // Add executor dependencies
}

impl ActionExecutor {
    pub fn new() -> Self {
        Self {}
    }

    pub async fn execute(&self, action: JeanAction) -> Result<ActionResult, String> {
        // Log action for auditing
        log::info!("Executing action: {:?}", action);
        
        // Execute based on action type
        match action.category {
            ActionCategory::Browser => self.execute_browser_action(action).await,
            ActionCategory::FileSystem => self.execute_filesystem_action(action).await,
            ActionCategory::System => self.execute_system_action(action).await,
            ActionCategory::Ecommerce => self.execute_ecommerce_action(action).await,
            _ => Ok(ActionResult {
                action_id: action.id,
                success: false,
                result_data: None,
                error_message: Some("Action category not implemented".to_string()),
            }),
        }
    }

    async fn execute_browser_action(&self, action: JeanAction) -> Result<ActionResult, String> {
        // Implement browser actions
        Ok(ActionResult {
            action_id: action.id,
            success: true,
            result_data: Some(serde_json::json!({"status": "completed"})),
            error_message: None,
        })
    }

    async fn execute_filesystem_action(&self, action: JeanAction) -> Result<ActionResult, String> {
        // Implement filesystem actions
        Ok(ActionResult {
            action_id: action.id,
            success: true,
            result_data: Some(serde_json::json!({"status": "completed"})),
            error_message: None,
        })
    }

    async fn execute_system_action(&self, action: JeanAction) -> Result<ActionResult, String> {
        // Implement system actions
        Ok(ActionResult {
            action_id: action.id,
            success: true,
            result_data: Some(serde_json::json!({"status": "completed"})),
            error_message: None,
        })
    }

    async fn execute_ecommerce_action(&self, action: JeanAction) -> Result<ActionResult, String> {
        // Implement e-commerce actions
        Ok(ActionResult {
            action_id: action.id,
            success: true,
            result_data: Some(serde_json::json!({"status": "completed"})),
            error_message: None,
        })
    }
}

pub struct AIClient {
    // Add AI client dependencies
}

impl AIClient {
    pub fn new() -> Self {
        Self {}
    }

    pub async fn process_message(
        &self,
        message: &str,
        user_context: &UserContext,
        memories: &[JeanMemory],
        action_analysis: &ActionAnalysis
    ) -> Result<AIResponse, String> {
        // Integrate with actual AI service
        // For now, return a simple response
        
        let response_message = format!(
            "I understand you want to: {}. Let me help you with that.",
            message
        );

        Ok(AIResponse {
            message: response_message,
            actions: Vec::new(),
            context_updates: None,
        })
    }
}

// Database models (add to models.rs later)
#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]
pub struct JeanPreferences {
    pub user_id: Uuid,
    pub initiative_level: String,
    pub language: String,
    pub theme: String,
    pub privacy_settings: serde_json::Value,
    pub notification_settings: serde_json::Value,
    pub tra_agent_preferences: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]
pub struct JeanPermission {
    pub id: Uuid,
    pub user_id: Uuid,
    pub action_type: String,
    pub scope: String,
    pub max_amount: Option<sqlx::types::Decimal>,
    pub usage_count: i32,
    pub max_usage: Option<i32>,
    pub expires_at: DateTime<Utc>,
    pub granted_at: DateTime<Utc>,
    pub description: Option<String>,
    pub is_active: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize, sqlx::FromRow)]
pub struct JeanSession {
    pub session_id: String,
    pub user_id: Uuid,
    pub context: serde_json::Value,
    pub active_strips: serde_json::Value,
    pub current_workspace: Option<Uuid>,
    pub last_activity: DateTime<Utc>,
    pub created_at: DateTime<Utc>,
    pub expires_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryContext {
    pub user_preferences: serde_json::Value,
    pub project_context: serde_json::Value,
    pub recent_memories: Vec<JeanMemory>,
    pub conversation_history: Vec<serde_json::Value>,
    pub active_permissions: Vec<serde_json::Value>,
    pub system_state: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemorySearchQuery {
    pub user_id: Uuid,
    pub query: String,
    pub memory_types: Option<Vec<String>>,
    pub context_tags: Option<Vec<String>>,
    pub limit: Option<i32>,
    pub relevance_threshold: Option<f64>,
    pub include_private: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryEntry {
    pub id: Uuid,
    pub memory_type: String,
    pub content: serde_json::Value,
    pub context_tags: Vec<String>,
    pub relevance_score: f64,
    pub access_count: i32,
    pub last_accessed: DateTime<Utc>,
    pub created_at: DateTime<Utc>,
}

impl JeanOrchestrator {
    /// Enhanced memory context retrieval
    pub async fn get_memory_context(
        &self,
        user_id: Uuid,
        session_id: Option<String>,
        current_context: Option<serde_json::Value>,
    ) -> CommandResult<MemoryContext> {
        let mut conn = self.pool.acquire().await
            .map_err(|e| format!("Failed to get connection: {}", e))?;

        // Get user preferences
        let preferences = sqlx::query!(
            r#"
            SELECT initiative_level, language, theme, privacy_settings, notification_settings
            FROM user_preferences 
            WHERE user_id = $1
            "#,
            user_id
        )
        .fetch_optional(&mut *conn)
        .await
        .map_err(|e| format!("Failed to get user preferences: {}", e))?;

        // Get recent memories
        let recent_memories = sqlx::query_as!(
            JeanMemory,
            r#"
            SELECT id, user_id, memory_type, content, context_tags, session_id,
                   is_private, is_archived, created_at, updated_at,
                   relevance_score as "relevance_score: f64",
                   access_count as "access_count: i32",
                   last_accessed, parent_memory_id, project_context
            FROM jean_memory 
            WHERE user_id = $1 AND is_private = false AND is_archived = false
            ORDER BY last_accessed DESC NULLS LAST, created_at DESC
            LIMIT 10
            "#,
            user_id
        )
        .fetch_all(&mut *conn)
        .await
        .map_err(|e| format!("Failed to get recent memories: {}", e))?;

        // Get active permissions
        let active_permissions = sqlx::query!(
            r#"
            SELECT action_type, scope, max_amount, max_usage, usage_count, expires_at
            FROM jean_permissions 
            WHERE user_id = $1 AND is_active = true AND expires_at > NOW()
            "#,
            user_id
        )
        .fetch_all(&mut *conn)
        .await
        .map_err(|e| format!("Failed to get active permissions: {}", e))?;

        // Get system state
        let service_status = sqlx::query!(
            r#"
            SELECT service_name, status, metrics, last_check
            FROM service_status 
            WHERE is_monitored = true
            ORDER BY service_name
            "#
        )
        .fetch_all(&mut *conn)
        .await
        .map_err(|e| format!("Failed to get service status: {}", e))?;

        let context = MemoryContext {
            user_preferences: serde_json::to_value(preferences).unwrap_or_default(),
            project_context: current_context.unwrap_or_default(),
            recent_memories,
            conversation_history: Vec::new(), // Would load from conversation table
            active_permissions: active_permissions.into_iter()
                .map(|p| serde_json::json!({
                    "action_type": p.action_type,
                    "scope": p.scope,
                    "max_amount": p.max_amount,
                    "remaining_uses": p.max_usage.map(|max| max - p.usage_count.unwrap_or(0))
                }))
                .collect(),
            system_state: serde_json::json!({
                "services": service_status.into_iter()
                    .map(|s| serde_json::json!({
                        "name": s.service_name,
                        "status": s.status,
                        "last_check": s.last_check
                    }))
                    .collect::<Vec<_>>()
            }),
        };

        Ok(context)
    }

    /// Smart memory search with relevance scoring
    pub async fn search_memory(
        &self,
        query: MemorySearchQuery,
    ) -> CommandResult<Vec<MemoryEntry>> {
        let mut conn = self.pool.acquire().await
            .map_err(|e| format!("Failed to get connection: {}", e))?;

        let memory_types = query.memory_types.unwrap_or_else(|| vec![
            "conversation".to_string(), "knowledge".to_string(), "preference".to_string()
        ]);

        // Build base query
        let mut sql = r#"
            SELECT id, memory_type, content, context_tags,
                   relevance_score, access_count, last_accessed, created_at,
                   ts_rank(search_vector, plainto_tsquery($2)) as rank
            FROM jean_memory 
            WHERE user_id = $1 
                AND memory_type = ANY($3)
        "#.to_string();

        if !query.include_private {
            sql.push_str(" AND is_private = false");
        }

        sql.push_str(" ORDER BY rank DESC, relevance_score DESC, last_accessed DESC NULLS LAST");

        if let Some(limit) = query.limit {
            sql.push_str(&format!(" LIMIT {}", limit));
        }

        // Use full-text search for better relevance
        let results = sqlx::query!(
            &sql,
            query.user_id,
            query.query,
            &memory_types
        )
        .fetch_all(&mut *conn)
        .await
        .map_err(|e| format!("Failed to search memory: {}", e))?;

        let entries: Vec<MemoryEntry> = results.into_iter()
            .filter_map(|row| {
                let relevance_score = row.relevance_score.unwrap_or(0.5);
                let rank = row.rank.unwrap_or(0.0);
                
                // Combine relevance_score with search rank
                let combined_score = (relevance_score + rank) / 2.0;

                if let Some(threshold) = query.relevance_threshold {
                    if combined_score < threshold {
                        return None;
                    }
                }

                Some(MemoryEntry {
                    id: row.id,
                    memory_type: row.memory_type,
                    content: row.content,
                    context_tags: row.context_tags.unwrap_or_default(),
                    relevance_score: combined_score,
                    access_count: row.access_count.unwrap_or(0),
                    last_accessed: row.last_accessed,
                    created_at: row.created_at,
                })
            })
            .collect();

        // Update access counts and last_accessed for returned memories
        if !entries.is_empty() {
            let memory_ids: Vec<Uuid> = entries.iter().map(|e| e.id).collect();
            sqlx::query!(
                r#"
                UPDATE jean_memory 
                SET access_count = access_count + 1, last_accessed = NOW()
                WHERE id = ANY($1)
                "#,
                &memory_ids
            )
            .execute(&mut *conn)
            .await
            .map_err(|e| format!("Failed to update memory access: {}", e))?;
        }

        Ok(entries)
    }

    /// Store new memory with automatic categorization
    pub async fn store_memory(
        &self,
        user_id: Uuid,
        memory_type: String,
        content: serde_json::Value,
        context_tags: Vec<String>,
        session_id: Option<String>,
        is_private: bool,
        parent_memory_id: Option<Uuid>,
    ) -> CommandResult<Uuid> {
        let mut conn = self.pool.acquire().await
            .map_err(|e| format!("Failed to get connection: {}", e))?;

        // Auto-generate additional context tags based on content
        let mut enhanced_tags = context_tags;
        if let Some(text) = content.as_str() {
            enhanced_tags.extend(Self::extract_keywords(text));
        }

        // Calculate initial relevance score
        let relevance_score = Self::calculate_relevance_score(&memory_type, &content, &enhanced_tags);

        let memory_id = sqlx::query_scalar!(
            r#"
            INSERT INTO jean_memory 
            (user_id, memory_type, content, context_tags, session_id, is_private,
             relevance_score, parent_memory_id, project_context)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
            RETURNING id
            "#,
            user_id,
            memory_type,
            content,
            &enhanced_tags,
            session_id,
            is_private,
            relevance_score,
            parent_memory_id,
            content // Store full content as project_context for now
        )
        .fetch_one(&mut *conn)
        .await
        .map_err(|e| format!("Failed to store memory: {}", e))?;

        Ok(memory_id)
    }

    /// Extract keywords from text for better searchability
    fn extract_keywords(text: &str) -> Vec<String> {
        let mut keywords = Vec::new();
        
        // Simple keyword extraction - in production would use NLP
        let patterns = vec![
            r"\b(?:alibaba|1688|amazon|aliexpress)\b", // Platforms
            r"\b(?:product|order|supplier|shipping)\b", // E-commerce
            r"\b(?:proxy|node|docker|service)\b", // Technical
            r"\b(?:permission|security|privacy)\b", // Security
        ];

        for pattern in patterns {
            if let Ok(regex) = Regex::new(pattern) {
                for cap in regex.find_iter(text) {
                    let keyword = cap.as_str().to_lowercase();
                    if !keywords.contains(&keyword) {
                        keywords.push(keyword);
                    }
                }
            }
        }

        keywords
    }

    /// Calculate relevance score based on content and tags
    fn calculate_relevance_score(memory_type: &str, content: &serde_json::Value, tags: &[String]) -> f64 {
        let mut score = 0.5; // Base score

        // Boost based on memory type
        match memory_type {
            "conversation" => score += 0.1,
            "knowledge" => score += 0.2,
            "preference" => score += 0.3,
            "context" => score += 0.15,
            _ => {}
        }

        // Boost based on content length and structure
        if let Some(text) = content.as_str() {
            if text.len() > 100 {
                score += 0.1;
            }
            if text.len() > 500 {
                score += 0.1;
            }
        }

        // Boost based on number of relevant tags
        let relevant_tags_count = tags.iter()
            .filter(|tag| tag.len() > 3)
            .count();
        score += (relevant_tags_count as f64 * 0.02).min(0.2);

        score.min(1.0)
    }

    /// Link related memories together
    pub async fn link_memories(
        &self,
        parent_memory_id: Uuid,
        child_memory_ids: Vec<Uuid>,
    ) -> CommandResult<usize> {
        if child_memory_ids.is_empty() {
            return Ok(0);
        }

        let mut conn = self.pool.acquire().await
            .map_err(|e| format!("Failed to get connection: {}", e))?;

        let result = sqlx::query!(
            r#"
            UPDATE jean_memory 
            SET parent_memory_id = $1
            WHERE id = ANY($2) AND parent_memory_id IS NULL
            "#,
            parent_memory_id,
            &child_memory_ids
        )
        .execute(&mut *conn)
        .await
        .map_err(|e| format!("Failed to link memories: {}", e))?;

        Ok(result.rows_affected() as usize)
    }

    /// Auto-categorize memory entries
    pub async fn auto_categorize_memories(&self, user_id: Uuid, limit: Option<i32>) -> CommandResult<i32> {
        let mut conn = self.pool.acquire().await
            .map_err(|e| format!("Failed to get connection: {}", e))?;

        // Get uncategorized memories
        let uncategorized = sqlx::query!(
            r#"
            SELECT id, content, context_tags
            FROM jean_memory 
            WHERE user_id = $1 
                AND context_tags IS NULL 
                AND context_tags = '{}'
            ORDER BY created_at DESC
            LIMIT $2
            "#,
            user_id,
            limit.unwrap_or(50)
        )
        .fetch_all(&mut *conn)
        .await
        .map_err(|e| format!("Failed to get uncategorized memories: {}", e))?;

        let mut categorized_count = 0;

        for memory in uncategorized {
            let new_tags = self.extract_context_tags(&memory.content).await;
            
            if !new_tags.is_empty() {
                sqlx::query!(
                    r#"
                    UPDATE jean_memory 
                    SET context_tags = $1
                    WHERE id = $2
                    "#,
                    &new_tags,
                    memory.id
                )
                .execute(&mut *conn)
                .await
                .map_err(|e| format!("Failed to categorize memory: {}", e))?;

                categorized_count += 1;
            }
        }

        Ok(categorized_count)
    }

    /// Extract context tags from memory content
    async fn extract_context_tags(&self, content: &serde_json::Value) -> Vec<String> {
        let mut tags = Vec::new();

        // Extract from content based on patterns
        if let Some(text) = content.as_str() {
            let text_lower = text.to_lowercase();

            // E-commerce related tags
            if text_lower.contains("product") || text_lower.contains("alibaba") || text_lower.contains("1688") {
                tags.push("ecommerce".to_string());
            }

            // Technical tags
            if text_lower.contains("docker") || text_lower.contains("server") || text_lower.contains("proxy") {
                tags.push("technical".to_string());
            }

            // Development tags
            if text_lower.contains("code") || text_lower.contains("programming") || text_lower.contains("development") {
                tags.push("development".to_string());
            }

            // Business tags
            if text_lower.contains("business") || text_lower.contains("strategy") || text_lower.contains("plan") {
                tags.push("business".to_string());
            }

            // Personal tags
            if text_lower.contains("personal") || text_lower.contains("private") || text_lower.contains("note") {
                tags.push("personal".to_string());
            }
        }

        // Extract from JSON structure
        if let Some(obj) = content.as_object() {
            for (key, _) in obj {
                tags.push(key.to_string());
            }
        }

        tags
    }

    /// Get memory statistics for analytics
    pub async fn get_memory_stats(
        &self,
        user_id: Uuid,
        days_back: i32,
    ) -> CommandResult<serde_json::Value> {
        let cutoff_date = Utc::now() - Duration::days(days_back as i64);
        let mut conn = self.pool.acquire().await
            .map_err(|e| format!("Failed to get connection: {}", e))?;

        // Memory creation over time
        let creation_stats = sqlx::query!(
            r#"
            SELECT 
                DATE(created_at) as date,
                COUNT(*) as count
            FROM jean_memory
            WHERE user_id = $1 AND created_at >= $2
            GROUP BY DATE(created_at)
            ORDER BY date DESC
            "#,
            user_id,
            cutoff_date
        )
        .fetch_all(&mut *conn)
        .await
        .map_err(|e| format!("Failed to get creation stats: {}", e))?;

        // Memory types distribution
        let type_stats = sqlx::query!(
            r#"
            SELECT 
                memory_type,
                COUNT(*) as count,
                AVG(relevance_score) as avg_relevance
            FROM jean_memory
            WHERE user_id = $1
            GROUP BY memory_type
            "#,
            user_id
        )
        .fetch_all(&mut *conn)
        .await
        .map_err(|e| format!("Failed to get type stats: {}", e))?;

        let stats = serde_json::json!({
            "creation_over_time": creation_stats.into_iter().map(|r| serde_json::json!({
                "date": r.date,
                "count": r.count.unwrap_or(0)
            })).collect::<Vec<_>>(),
            "memory_types": type_stats.into_iter().map(|r| serde_json::json!({
                "type": r.memory_type,
                "count": r.count.unwrap_or(0),
                "avg_relevance": r.avg_relevance.unwrap_or(0.0)
            })).collect::<Vec<_>>(),
            "period_days": days_back
        });

        Ok(stats)
    }
}

// Enhanced Memory Management
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemorySearchRequest {
    pub user_id: Uuid,
    pub query: String,
    pub memory_types: Option<Vec<String>>,
    pub context_tags: Option<Vec<String>>,
    pub session_id: Option<String>,
    pub limit: Option<i32>,
    pub relevance_threshold: Option<f32>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryEntry {
    pub id: Uuid,
    pub user_id: Uuid,
    pub memory_type: String,
    pub content: serde_json::Value,
    pub context_tags: Vec<String>,
    pub session_id: Option<String>,
    pub is_private: bool,
    pub relevance_score: f32,
    pub access_count: i32,
    pub last_accessed: Option<DateTime<Utc>>,
    pub project_context: Option<serde_json::Value>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContextAnalysis {
    pub current_tab_url: Option<String>,
    pub active_strips: Vec<String>,
    pub workspace_name: Option<String>,
    pub recent_actions: Vec<String>,
    pub relevant_memories: Vec<MemoryEntry>,
    pub project_context: Option<serde_json::Value>,
}

impl JeanOrchestrator {
    /// Enhanced memory search with relevance scoring
    pub async fn search_memory(
        &self,
        request: MemorySearchRequest,
    ) -> CommandResult<Vec<MemoryEntry>> {
        let mut conn = self.db_pool.acquire().await
            .map_err(|e| format!("Failed to get connection: {}", e))?;

        let mut query = "
            SELECT 
                id, user_id, memory_type, content, 
                context_tags, session_id, is_private,
                relevance_score, access_count, last_accessed,
                project_context, created_at, updated_at
            FROM jean_memory 
            WHERE user_id = $1
        ".to_string();

        let mut params: Vec<Box<dyn sqlx::Encode<'_, sqlx::Postgres> + Send>> = vec![Box::new(request.user_id)];
        let mut param_index = 2;

        if let Some(types) = &request.memory_types {
            query.push_str(&format!(" AND memory_type = ANY(${})", param_index));
            params.push(Box::new(types.clone()));
            param_index += 1;
        }

        if let Some(tags) = &request.context_tags {
            query.push_str(&format!(" AND context_tags && ${}", param_index));
            params.push(Box::new(tags.clone()));
            param_index += 1;
        }

        if let Some(session) = &request.session_id {
            query.push_str(&format!(" AND session_id = ${}", param_index));
            params.push(Box::new(session.clone()));
            param_index += 1;
        }

        if let Some(threshold) = request.relevance_threshold {
            query.push_str(&format!(" AND relevance_score >= ${}", param_index));
            params.push(Box::new(threshold));
            param_index += 1;
        }

        query.push_str(" ORDER BY relevance_score DESC, last_accessed DESC NULLS LAST");

        if let Some(limit) = request.limit {
            query.push_str(&format!(" LIMIT {}", limit));
        }

        // Execute query with parameters
        let memories = sqlx::query_as::<_, MemoryEntry>(&query)
            .bind(request.user_id)
            .fetch_all(&mut *conn)
            .await
            .map_err(|e| format!("Failed to search memory: {}", e))?;

        // Update access count for returned memories
        for memory in &memories {
            let _ = sqlx::query!(
                "UPDATE jean_memory SET access_count = access_count + 1, last_accessed = NOW() WHERE id = $1",
                memory.id
            )
            .execute(&mut *conn)
            .await;
        }

        Ok(memories)
    }

    /// Save memory entry with automatic relevance scoring
    pub async fn save_memory(
        &self,
        user_id: Uuid,
        memory_type: String,
        content: serde_json::Value,
        context_tags: Vec<String>,
        session_id: Option<String>,
        is_private: bool,
        project_context: Option<serde_json::Value>,
    ) -> CommandResult<MemoryEntry> {
        let mut conn = self.db_pool.acquire().await
            .map_err(|e| format!("Failed to get connection: {}", e))?;

        // Calculate relevance score based on content and tags
        let relevance_score = self.calculate_relevance_score(&content, &context_tags);

        let memory_id = Uuid::new_v4();

        sqlx::query!(
            r#"
            INSERT INTO jean_memory (
                id, user_id, memory_type, content, context_tags,
                session_id, is_private, relevance_score,
                access_count, last_accessed, project_context
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, 0, NOW(), $9)
            "#,
            memory_id,
            user_id,
            memory_type,
            content,
            &context_tags,
            session_id,
            is_private,
            relevance_score,
            project_context
        )
        .execute(&mut *conn)
        .await
        .map_err(|e| format!("Failed to save memory: {}", e))?;

        // Return the saved memory
        let memory = sqlx::query_as!(
            MemoryEntry,
            r#"
            SELECT 
                id, user_id, memory_type, content,
                context_tags, session_id, is_private,
                relevance_score, access_count, last_accessed,
                project_context, created_at, updated_at
            FROM jean_memory WHERE id = $1
            "#,
            memory_id
        )
        .fetch_one(&mut *conn)
        .await
        .map_err(|e| format!("Failed to retrieve saved memory: {}", e))?;

        Ok(memory)
    }

    /// Link related memories together
    pub async fn link_memories(
        &self,
        parent_id: Uuid,
        child_id: Uuid,
    ) -> CommandResult<()> {
        let mut conn = self.db_pool.acquire().await
            .map_err(|e| format!("Failed to get connection: {}", e))?;

        sqlx::query!(
            "UPDATE jean_memory SET parent_memory_id = $1 WHERE id = $2",
            parent_id,
            child_id
        )
        .execute(&mut *conn)
        .await
        .map_err(|e| format!("Failed to link memories: {}", e))?;

        Ok(())
    }

    /// Get context for current session including relevant memories
    pub async fn get_session_context(
        &self,
        user_id: Uuid,
        session_id: &str,
    ) -> CommandResult<ContextAnalysis> {
        let mut conn = self.db_pool.acquire().await
            .map_err(|e| format!("Failed to get connection: {}", e))?;

        // Get recent memories for this session
        let recent_memories = sqlx::query_as!(
            MemoryEntry,
            r#"
            SELECT 
                id, user_id, memory_type, content,
                context_tags, session_id, is_private,
                relevance_score, access_count, last_accessed,
                project_context, created_at, updated_at
            FROM jean_memory 
            WHERE user_id = $1 AND (session_id = $2 OR parent_memory_id IN (
                SELECT id FROM jean_memory WHERE session_id = $2
            ))
            ORDER BY created_at DESC
            LIMIT 10
            "#,
            user_id,
            session_id
        )
        .fetch_all(&mut *conn)
        .await
        .map_err(|e| format!("Failed to get session memories: {}", e))?;

        // Get recent actions
        let recent_actions = sqlx::query!(
            r#"
            SELECT action_type, created_at
            FROM jean_actions_log
            WHERE user_id = $1 AND session_id = $2
            ORDER BY created_at DESC
            LIMIT 5
            "#,
            user_id,
            session_id
        )
        .fetch_all(&mut *conn)
        .await
        .map_err(|e| format!("Failed to get recent actions: {}", e))?;

        let context = ContextAnalysis {
            current_tab_url: None, // Would get from browser state
            active_strips: vec![], // Would get from session data
            workspace_name: None, // Would get from workspace data
            recent_actions: recent_actions.into_iter()
                .map(|a| a.action_type)
                .collect(),
            relevant_memories: recent_memories,
            project_context: None, // Would derive from memories
        };

        Ok(context)
    }

    /// Calculate relevance score for memory content
    fn calculate_relevance_score(&self, content: &serde_json::Value, tags: &[String]) -> f32 {
        let mut score = 0.5; // Base score

        // Boost score for certain content types
        if let Some(content_str) = content.as_str() {
            // Longer content gets higher score
            score += (content_str.len() as f32 / 1000.0).min(0.3);
            
            // Important keywords
            let important_keywords = ["decision", "important", "critical", "todo", "bug", "feature"];
            for keyword in &important_keywords {
                if content_str.to_lowercase().contains(keyword) {
                    score += 0.1;
                }
            }
        }

        // Boost score for specific tags
        let important_tags = ["project", "decision", "bug", "feature", "user-preference"];
        for tag in tags {
            if important_tags.contains(&tag.as_str()) {
                score += 0.1;
            }
        }

        score.min(1.0)
    }

    /// Cleanup old/archived memories
    pub async fn cleanup_old_memories(&self, days_old: i32) -> CommandResult<i32> {
        let cutoff_date = chrono::Utc::now() - chrono::Duration::days(days_old as i64);
        
        let result = sqlx::query!(
            r#"
            UPDATE jean_memory 
            SET is_archived = true 
            WHERE created_at < $1 
                AND is_archived = false 
                AND relevance_score < 0.3
            "#,
            cutoff_date
        )
        .execute(&self.db_pool)
        .await
        .map_err(|e| format!("Failed to cleanup old memories: {}", e))?;

        Ok(result.rows_affected() as i32)
    }

    /// Get memory statistics for analytics
    pub async fn get_memory_stats(&self, user_id: Uuid) -> CommandResult<serde_json::Value> {
        let mut conn = self.db_pool.acquire().await
            .map_err(|e| format!("Failed to get connection: {}", e))?;

        // Memory counts by type
        let memory_by_type = sqlx::query!(
            r#"
            SELECT memory_type, COUNT(*) as count
            FROM jean_memory
            WHERE user_id = $1 AND is_archived = false
            GROUP BY memory_type
            "#,
            user_id
        )
        .fetch_all(&mut *conn)
        .await
        .map_err(|e| format!("Failed to get memory type stats: {}", e))?;

        // Most accessed memories
        let most_accessed = sqlx::query!(
            r#"
            SELECT 
                memory_type, 
                SUM(access_count) as total_access,
                AVG(relevance_score) as avg_relevance
            FROM jean_memory
            WHERE user_id = $1 AND is_archived = false
            GROUP BY memory_type
            ORDER BY total_access DESC
            LIMIT 5
            "#,
            user_id
        )
        .fetch_all(&mut *conn)
        .await
        .map_err(|e| format!("Failed to get access stats: {}", e))?;

        let stats = serde_json::json!({
            "memory_by_type": memory_by_type.into_iter().map(|r| serde_json::json!({
                "type": r.memory_type,
                "count": r.count.unwrap_or(0)
            })).collect::<Vec<_>>(),
            "most_accessed": most_accessed.into_iter().map(|r| serde_json::json!({
                "type": r.memory_type,
                "total_access": r.total_access.unwrap_or(0),
                "avg_relevance": r.avg_relevance.unwrap_or(0.0)
            })).collect::<Vec<_>>()
        });

        Ok(stats)
    }
}