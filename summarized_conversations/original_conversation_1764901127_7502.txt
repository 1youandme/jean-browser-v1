{'role': 'assistant', 'content': '\n<function_calls>\n<create-file file_path="src/services/medialibrary.ts">\n// Media Library Service Interface and Implementation\nexport interface MediaFile {\n  id: string;\n  name: string;\n  originalName: string;\n  type: MediaType;\n  mimeType: string;\n  size: number;\n  url: string;\n  thumbnailUrl?: string;\n  duration?: number;\n  dimensions?: {\n    width: number;\n    height: number;\n  };\n  metadata: MediaMetadata;\n  tags: string[];\n  category?: string;\n  albums: string[];\n  isFavorite: boolean;\n  isPublic: boolean;\n  uploadedAt: Date;\n  modifiedAt: Date;\n  uploadedBy: string;\n}\n\nexport type MediaType = \'image\' | \'video\' | \'audio\' | \'document\' | \'archive\';\n\nexport interface MediaMetadata {\n  title?: string;\n  description?: string;\n  artist?: string;\n  album?: string;\n  year?: number;\n  genre?: string;\n  camera?: string;\n  location?: {\n    name: string;\n    coordinates: {\n      lat: number;\n      lng: number;\n    };\n  };\n  exif?: Record<string, any>;\n  colors?: string[];\n}\n\nexport interface Album {\n  id: string;\n  name: string;\n  description?: string;\n  coverImageUrl?: string;\n  mediaCount: number;\n  totalSize: number;\n  duration?: number;\n  isPublic: boolean;\n  tags: string[];\n  createdAt: Date;\n  updatedAt: Date;\n  createdBy: string;\n}\n\nexport interface MediaLibraryStats {\n  totalFiles: number;\n  totalSize: number;\n  filesByType: Record<MediaType, number>;\n  sizeByType: Record<MediaType, number>;\n  totalDuration: number;\n  favoriteCount: number;\n  albumCount: number;\n  tagsCount: number;\n}\n\nexport interface SearchFilters {\n  type?: MediaType[];\n  tags?: string[];\n  category?: string;\n  uploadedBy?: string;\n  dateRange?: {\n    from: Date;\n    to: Date;\n  };\n  sizeRange?: {\n    min: number;\n    max: number;\n  };\n  durationRange?: {\n    min: number;\n    max: number;\n  };\n  isFavorite?: boolean;\n  isPublic?: boolean;\n}\n\nexport interface MediaLibraryService {\n  // File management\n  uploadFile: (file: File, metadata?: Partial<MediaMetadata>) => Promise<MediaFile>;\n  uploadFiles: (files: File[], metadata?: Partial<MediaMetadata>) => Promise<MediaFile[]>;\n  getFiles: (filters?: SearchFilters, page?: number, limit?: number) => Promise<{ files: MediaFile[]; total: number }>;\n  getFile: (id: string) => Promise<MediaFile>;\n  updateFile: (id: string, updates: Partial<MediaFile>) => Promise<MediaFile>;\n  deleteFile: (id: string) => Promise<void>;\n  deleteFiles: (ids: string[]) => Promise<void>;\n  \n  // File operations\n  favoriteFile: (id: string) => Promise<void>;\n  unfavoriteFile: (id: string) => Promise<void>;\n  getFavoriteFiles: () => Promise<MediaFile[]>;\n  downloadFile: (id: string) => Promise<Blob>;\n  getFileStream: (id: string) => Promise<ReadableStream>;\n  \n  // Album management\n  createAlbum: (name: string, description?: string) => Promise<Album>;\n  getAlbums: () => Promise<Album[]>;\n  getAlbum: (id: string) => Promise<Album>;\n  updateAlbum: (id: string, updates: Partial<Album>) => Promise<Album>;\n  deleteAlbum: (id: string) => Promise<void>;\n  addFilesToAlbum: (albumId: string, fileIds: string[]) => Promise<void>;\n  removeFilesFromAlbum: (albumId: string, fileIds: string[]) => Promise<void>;\n  getAlbumFiles: (albumId: string) => Promise<MediaFile[]>;\n  \n  // Search and filtering\n  searchFiles: (query: string, filters?: SearchFilters) => Promise<MediaFile[]>;\n  getFilesByTag: (tag: string) => Promise<MediaFile[]>;\n  getFilesByType: (type: MediaType) => Promise<MediaFile[]>;\n  getRecentFiles: (limit?: number) => Promise<MediaFile[]>;\n  \n  // Tags management\n  getAllTags: () => Promise<string[]>;\n  addTag: (tag: string) => Promise<void>;\n  removeTag: (tag: string) => Promise<void>;\n  renameTag: (oldTag: string, newTag: string) => Promise<void>;\n  \n  // Sharing and permissions\n  shareFile: (id: string, isPublic: boolean) => Promise<string>;\n  getShareLink: (id: string) => Promise<string>;\n  revokeShare: (id: string) => Promise<void>;\n  \n  // Analytics and stats\n  getLibraryStats: () => Promise<MediaLibraryStats>;\n  getFileStats: (id: string) => Promise<{ views: number; downloads: number; shares: number }>;\n  \n  // Processing and conversion\n  generateThumbnail: (id: string) => Promise<string>;\n  convertFile: (id: string, targetFormat: string) => Promise<MediaFile>;\n  extractMetadata: (id: string) => Promise<MediaMetadata>;\n  \n  // Batch operations\n  batchUpdateTags: (fileIds: string[], tags: string[]) => Promise<void>;\n  batchAddToAlbum: (fileIds: string[], albumId: string) => Promise<void>;\n  batchDelete: (fileIds: string[]) => Promise<void>;\n  \n  // Streaming\n  streamVideo: (id: string, quality?: \'low\' | \'medium\' | \'high\') => Promise<ReadableStream>;\n  streamAudio: (id: string) => Promise<ReadableStream>;\n}\n\nexport interface UploadProgress {\n  loaded: number;\n  total: number;\n  percentage: number;\n}\n\nclass MediaLibraryServiceImpl implements MediaLibraryService {\n  private baseUrl: string;\n\n  constructor(baseUrl: string = \'http://localhost:8080\') {\n    this.baseUrl = baseUrl;\n  }\n\n  async uploadFile(file: File, metadata?: Partial<MediaMetadata>): Promise<MediaFile> {\n    const formData = new FormData();\n    formData.append(\'file\', file);\n    if (metadata) {\n      Object.entries(metadata).forEach(([key, value]) => {\n        if (value !== undefined) {\n          formData.append(key, JSON.stringify(value));\n        }\n      });\n    }\n\n    const response = await fetch(`${this.baseUrl}/api/media/upload`, {\n      method: \'POST\',\n      body: formData,\n    });\n    if (!response.ok) throw new Error(\'Failed to upload file\');\n    return response.json();\n  }\n\n  async uploadFiles(files: File[], metadata?: Partial<MediaMetadata>): Promise<MediaFile[]> {\n    const formData = new FormData();\n    files.forEach(file => formData.append(\'files\', file));\n    if (metadata) {\n      Object.entries(metadata).forEach(([key, value]) => {\n        if (value !== undefined) {\n          formData.append(key, JSON.stringify(value));\n        }\n      });\n    }\n\n    const response = await fetch(`${this.baseUrl}/api/media/upload/batch`, {\n      method: \'POST\',\n      body: formData,\n    });\n    if (!response.ok) throw new Error(\'Failed to upload files\');\n    return response.json();\n  }\n\n  async getFiles(filters?: SearchFilters, page?: number, limit?: number): Promise<{ files: MediaFile[]; total: number }> {\n    const params = new URLSearchParams();\n    if (page) params.append(\'page\', page.toString());\n    if (limit) params.append(\'limit\', limit.toString());\n    if (filters) {\n      Object.entries(filters).forEach(([key, value]) => {\n        if (value !== undefined) {\n          if (Array.isArray(value)) {\n            value.forEach(v => params.append(key, v));\n          } else {\n            params.append(key, String(value));\n          }\n        }\n      });\n    }\n\n    const response = await fetch(`${this.baseUrl}/api/media/files?${params}`);\n    if (!response.ok) throw new Error(\'Failed to get files\');\n    return response.json();\n  }\n\n  async getFile(id: string): Promise<MediaFile> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/${id}`);\n    if (!response.ok) throw new Error(\'Failed to get file\');\n    return response.json();\n  }\n\n  async updateFile(id: string, updates: Partial<MediaFile>): Promise<MediaFile> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/${id}`, {\n      method: \'PUT\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify(updates),\n    });\n    if (!response.ok) throw new Error(\'Failed to update file\');\n    return response.json();\n  }\n\n  async deleteFile(id: string): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/${id}`, {\n      method: \'DELETE\',\n    });\n    if (!response.ok) throw new Error(\'Failed to delete file\');\n  }\n\n  async deleteFiles(ids: string[]): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/batch-delete`, {\n      method: \'DELETE\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify({ ids }),\n    });\n    if (!response.ok) throw new Error(\'Failed to delete files\');\n  }\n\n  async favoriteFile(id: string): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/${id}/favorite`, {\n      method: \'POST\',\n    });\n    if (!response.ok) throw new Error(\'Failed to favorite file\');\n  }\n\n  async unfavoriteFile(id: string): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/${id}/favorite`, {\n      method: \'DELETE\',\n    });\n    if (!response.ok) throw new Error(\'Failed to unfavorite file\');\n  }\n\n  async getFavoriteFiles(): Promise<MediaFile[]> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/favorites`);\n    if (!response.ok) throw new Error(\'Failed to get favorite files\');\n    return response.json();\n  }\n\n  async downloadFile(id: string): Promise<Blob> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/${id}/download`);\n    if (!response.ok) throw new Error(\'Failed to download file\');\n    return response.blob();\n  }\n\n  async getFileStream(id: string): Promise<ReadableStream> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/${id}/stream`);\n    if (!response.ok) throw new Error(\'Failed to get file stream\');\n    return response.body!;\n  }\n\n  async createAlbum(name: string, description?: string): Promise<Album> {\n    const response = await fetch(`${this.baseUrl}/api/media/albums`, {\n      method: \'POST\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify({ name, description }),\n    });\n    if (!response.ok) throw new Error(\'Failed to create album\');\n    return response.json();\n  }\n\n  async getAlbums(): Promise<Album[]> {\n    const response = await fetch(`${this.baseUrl}/api/media/albums`);\n    if (!response.ok) throw new Error(\'Failed to get albums\');\n    return response.json();\n  }\n\n  async getAlbum(id: string): Promise<Album> {\n    const response = await fetch(`${this.baseUrl}/api/media/albums/${id}`);\n    if (!response.ok) throw new Error(\'Failed to get album\');\n    return response.json();\n  }\n\n  async updateAlbum(id: string, updates: Partial<Album>): Promise<Album> {\n    const response = await fetch(`${this.baseUrl}/api/media/albums/${id}`, {\n      method: \'PUT\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify(updates),\n    });\n    if (!response.ok) throw new Error(\'Failed to update album\');\n    return response.json();\n  }\n\n  async deleteAlbum(id: string): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/media/albums/${id}`, {\n      method: \'DELETE\',\n    });\n    if (!response.ok) throw new Error(\'Failed to delete album\');\n  }\n\n  async addFilesToAlbum(albumId: string, fileIds: string[]): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/media/albums/${albumId}/files`, {\n      method: \'POST\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify({ fileIds }),\n    });\n    if (!response.ok) throw new Error(\'Failed to add files to album\');\n  }\n\n  async removeFilesFromAlbum(albumId: string, fileIds: string[]): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/media/albums/${albumId}/files`, {\n      method: \'DELETE\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify({ fileIds }),\n    });\n    if (!response.ok) throw new Error(\'Failed to remove files from album\');\n  }\n\n  async getAlbumFiles(albumId: string): Promise<MediaFile[]> {\n    const response = await fetch(`${this.baseUrl}/api/media/albums/${albumId}/files`);\n    if (!response.ok) throw new Error(\'Failed to get album files\');\n    return response.json();\n  }\n\n  async searchFiles(query: string, filters?: SearchFilters): Promise<MediaFile[]> {\n    const params = new URLSearchParams({ query });\n    if (filters) {\n      Object.entries(filters).forEach(([key, value]) => {\n        if (value !== undefined) {\n          if (Array.isArray(value)) {\n            value.forEach(v => params.append(key, v));\n          } else {\n            params.append(key, String(value));\n          }\n        }\n      });\n    }\n\n    const response = await fetch(`${this.baseUrl}/api/media/search?${params}`);\n    if (!response.ok) throw new Error(\'Failed to search files\');\n    return response.json();\n  }\n\n  async getFilesByTag(tag: string): Promise<MediaFile[]> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/tag/${encodeURIComponent(tag)}`);\n    if (!response.ok) throw new Error(\'Failed to get files by tag\');\n    return response.json();\n  }\n\n  async getFilesByType(type: MediaType): Promise<MediaFile[]> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/type/${type}`);\n    if (!response.ok) throw new Error(\'Failed to get files by type\');\n    return response.json();\n  }\n\n  async getRecentFiles(limit?: number): Promise<MediaFile[]> {\n    const url = limit ? `${this.baseUrl}/api/media/files/recent?limit=${limit}` : `${this.baseUrl}/api/media/files/recent`;\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(\'Failed to get recent files\');\n    return response.json();\n  }\n\n  async getAllTags(): Promise<string[]> {\n    const response = await fetch(`${this.baseUrl}/api/media/tags`);\n    if (!response.ok) throw new Error(\'Failed to get all tags\');\n    return response.json();\n  }\n\n  async addTag(tag: string): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/media/tags`, {\n      method: \'POST\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify({ tag }),\n    });\n    if (!response.ok) throw new Error(\'Failed to add tag\');\n  }\n\n  async removeTag(tag: string): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/media/tags/${encodeURIComponent(tag)}`, {\n      method: \'DELETE\',\n    });\n    if (!response.ok) throw new Error(\'Failed to remove tag\');\n  }\n\n  async renameTag(oldTag: string, newTag: string): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/media/tags/${encodeURIComponent(oldTag)}`, {\n      method: \'PUT\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify({ newTag }),\n    });\n    if (!response.ok) throw new Error(\'Failed to rename tag\');\n  }\n\n  async shareFile(id: string, isPublic: boolean): Promise<string> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/${id}/share`, {\n      method: \'POST\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify({ isPublic }),\n    });\n    if (!response.ok) throw new Error(\'Failed to share file\');\n    const result = await response.json();\n    return result.shareUrl;\n  }\n\n  async getShareLink(id: string): Promise<string> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/${id}/share`);\n    if (!response.ok) throw new Error(\'Failed to get share link\');\n    const result = await response.json();\n    return result.shareUrl;\n  }\n\n  async revokeShare(id: string): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/${id}/share`, {\n      method: \'DELETE\',\n    });\n    if (!response.ok) throw new Error(\'Failed to revoke share\');\n  }\n\n  async getLibraryStats(): Promise<MediaLibraryStats> {\n    const response = await fetch(`${this.baseUrl}/api/media/stats`);\n    if (!response.ok) throw new Error(\'Failed to get library stats\');\n    return response.json();\n  }\n\n  async getFileStats(id: string): Promise<{ views: number; downloads: number; shares: number }> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/${id}/stats`);\n    if (!response.ok) throw new Error(\'Failed to get file stats\');\n    return response.json();\n  }\n\n  async generateThumbnail(id: string): Promise<string> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/${id}/thumbnail`, {\n      method: \'POST\',\n    });\n    if (!response.ok) throw new Error(\'Failed to generate thumbnail\');\n    const result = await response.json();\n    return result.thumbnailUrl;\n  }\n\n  async convertFile(id: string, targetFormat: string): Promise<MediaFile> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/${id}/convert`, {\n      method: \'POST\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify({ targetFormat }),\n    });\n    if (!response.ok) throw new Error(\'Failed to convert file\');\n    return response.json();\n  }\n\n  async extractMetadata(id: string): Promise<MediaMetadata> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/${id}/metadata`);\n    if (!response.ok) throw new Error(\'Failed to extract metadata\');\n    return response.json();\n  }\n\n  async batchUpdateTags(fileIds: string[], tags: string[]): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/batch-update-tags`, {\n      method: \'POST\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify({ fileIds, tags }),\n    });\n    if (!response.ok) throw new Error(\'Failed to batch update tags\');\n  }\n\n  async batchAddToAlbum(fileIds: string[], albumId: string): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/batch-add-to-album`, {\n      method: \'POST\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify({ fileIds, albumId }),\n    });\n    if (!response.ok) throw new Error(\'Failed to batch add to album\');\n  }\n\n  async batchDelete(fileIds: string[]): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/batch-delete`, {\n      method: \'DELETE\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify({ fileIds }),\n    });\n    if (!response.ok) throw new Error(\'Failed to batch delete\');\n  }\n\n  async streamVideo(id: string, quality?: \'low\' | \'medium\' | \'high\'): Promise<ReadableStream> {\n    const params = quality ? `?quality=${quality}` : \'\';\n    const response = await fetch(`${this.baseUrl}/api/media/files/${id}/stream/video${params}`);\n    if (!response.ok) throw new Error(\'Failed to stream video\');\n    return response.body!;\n  }\n\n  async streamAudio(id: string): Promise<ReadableStream> {\n    const response = await fetch(`${this.baseUrl}/api/media/files/${id}/stream/audio`);\n    if (!response.ok) throw new Error(\'Failed to stream audio\');\n    return response.body!;\n  }\n}\n\nexport const mediaLibraryService = new MediaLibraryServiceImpl();\nexport const useMediaLibraryService = () => mediaLibraryService;\n</create-file>\n</function_calls>'}