{'role': 'assistant', 'content': '\n## ðŸŽ¯ Creating 3D Animated Jean Character\n\nNow I\'ll create the 3D animated Jean character component with lip sync, mouse tracking, and facial expressions:\n\n<function_calls>\n<create-file file_path="jeantrail_project/src/components/Jean3DModel.tsx">\nimport React, { useRef, useEffect, useState, useCallback } from \'react\';\nimport * as THREE from \'three\';\nimport { OrbitControls } from \'three/examples/jsm/controls/OrbitControls\';\nimport { GLTFLoader } from \'three/examples/jsm/loaders/GLTFLoader\';\nimport { AnimationMixer, Clock, Vector2, Raycaster } from \'three\';\nimport { \n  MessageSquare, \n  Smile, \n  Frown, \n  Meh, \n  Heart, \n  Zap, \n  Eye, \n  EyeOff, \n  Volume2, \n  VolumeX \n} from \'lucide-react\';\n\n// Types\ninterface Jean3DModelProps {\n  modelPath?: string;\n  isSpeaking?: boolean;\n  audioLevel?: number;\n  emotion?: \'neutral\' | \'happy\' | \'sad\' | \'thinking\' | \'excited\' | \'angry\';\n  isVisible?: boolean;\n  mouseTracking?: boolean;\n  autoRotate?: boolean;\n  scale?: number;\n  position?: [number, number, number];\n  onModelLoaded?: () => void;\n  onAnimationComplete?: () => void;\n}\n\ninterface FacialExpression {\n  name: string;\n  blendShapes: { [key: string]: number };\n  duration: number;\n}\n\ninterface LipSyncData {\n  visemes: Array<{\n    viseme: number;\n    weight: number;\n    duration: number;\n  }>;\n}\n\n// Mock facial expressions (would be configured based on actual model)\nconst FACIAL_EXPRESSIONS: { [key: string]: FacialExpression } = {\n  neutral: {\n    name: \'neutral\',\n    blendShapes: {\n      \'mouthSmile\': 0,\n      \'mouthFrown\': 0,\n      \'eyeBlinkLeft\': 0,\n      \'eyeBlinkRight\': 0,\n      \'browDownLeft\': 0,\n      \'browDownRight\': 0,\n      \'jawOpen\': 0\n    },\n    duration: 500\n  },\n  happy: {\n    name: \'happy\',\n    blendShapes: {\n      \'mouthSmile\': 0.8,\n      \'mouthFrown\': 0,\n      \'eyeBlinkLeft\': 0.1,\n      \'eyeBlinkRight\': 0.1,\n      \'browDownLeft\': -0.3,\n      \'browDownRight\': -0.3,\n      \'jawOpen\': 0.2\n    },\n    duration: 1000\n  },\n  sad: {\n    name: \'sad\',\n    blendShapes: {\n      \'mouthSmile\': 0,\n      \'mouthFrown\': 0.6,\n      \'eyeBlinkLeft\': 0.3,\n      \'eyeBlinkRight\': 0.3,\n      \'browDownLeft\': 0.5,\n      \'browDownRight\': 0.5,\n      \'jawOpen\': 0\n    },\n    duration: 800\n  },\n  thinking: {\n    name: \'thinking\',\n    blendShapes: {\n      \'mouthSmile\': 0.1,\n      \'mouthFrown\': 0.2,\n      \'eyeBlinkLeft\': 0.5,\n      \'eyeBlinkRight\': 0.5,\n      \'browDownLeft\': 0.3,\n      \'browDownRight\': 0.3,\n      \'jawOpen\': 0.1\n    },\n    duration: 600\n  },\n  excited: {\n    name: \'excited\',\n    blendShapes: {\n      \'mouthSmile\': 1.0,\n      \'mouthFrown\': 0,\n      \'eyeBlinkLeft\': 0.1,\n      \'eyeBlinkRight\': 0.1,\n      \'browDownLeft\': -0.5,\n      \'browDownRight\': -0.5,\n      \'jawOpen\': 0.4\n    },\n    duration: 1200\n  },\n  angry: {\n    name: \'angry\',\n    blendShapes: {\n      \'mouthSmile\': 0,\n      \'mouthFrown\': 0.8,\n      \'eyeBlinkLeft\': 0.2,\n      \'eyeBlinkRight\': 0.2,\n      \'browDownLeft\': 0.8,\n      \'browDownRight\': 0.8,\n      \'jawOpen\': 0.3\n    },\n    duration: 700\n  }\n};\n\n// Main Component\nexport const Jean3DModel: React.FC<Jean3DModelProps> = ({\n  modelPath = \'/models/jean-character.glb\',\n  isSpeaking = false,\n  audioLevel = 0,\n  emotion = \'neutral\',\n  isVisible = true,\n  mouseTracking = true,\n  autoRotate = false,\n  scale = 1.0,\n  position = [0, 0, 0],\n  onModelLoaded,\n  onAnimationComplete\n}) => {\n  const mountRef = useRef<HTMLDivElement>(null);\n  const sceneRef = useRef<THREE.Scene | null>(null);\n  const rendererRef = useRef<THREE.WebGLRenderer | null>(null);\n  const cameraRef = useRef<THREE.PerspectiveCamera | null>(null);\n  const modelRef = useRef<THREE.Group | null>(null);\n  const mixerRef = useRef<AnimationMixer | null>(null);\n  const clockRef = useRef<Clock>(new Clock());\n  const controlsRef = useRef<OrbitControls | null>(null);\n  const frameRef = useRef<number>();\n  \n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [currentEmotion, setCurrentEmotion] = useState(emotion);\n  const [isModelVisible, setIsModelVisible] = useState(isVisible);\n  const [mousePosition, setMousePosition] = useState({ x: 0, y: 0 });\n\n  // Initialize Three.js scene\n  const initScene = useCallback(() => {\n    if (!mountRef.current) return;\n\n    // Scene setup\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(0xf0f0f0);\n    sceneRef.current = scene;\n\n    // Camera setup\n    const camera = new THREE.PerspectiveCamera(\n      75,\n      mountRef.current.clientWidth / mountRef.current.clientHeight,\n      0.1,\n      1000\n    );\n    camera.position.set(0, 1.6, 3);\n    cameraRef.current = camera;\n\n    // Renderer setup\n    const renderer = new THREE.WebGLRenderer({ \n      antialias: true, \n      alpha: true \n    });\n    renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.shadowMap.enabled = true;\n    renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n    mountRef.current.appendChild(renderer.domElement);\n    rendererRef.current = renderer;\n\n    // Controls setup\n    const controls = new OrbitControls(camera, renderer.domElement);\n    controls.enableDamping = true;\n    controls.dampingFactor = 0.05;\n    controls.screenSpacePanning = false;\n    controls.minDistance = 1;\n    controls.maxDistance = 10;\n    controls.maxPolarAngle = Math.PI;\n    controlsRef.current = controls;\n\n    // Lighting setup\n    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);\n    scene.add(ambientLight);\n\n    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);\n    directionalLight.position.set(5, 10, 7.5);\n    directionalLight.castShadow = true;\n    directionalLight.shadow.mapSize.width = 2048;\n    directionalLight.shadow.mapSize.height = 2048;\n    scene.add(directionalLight);\n\n    const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);\n    fillLight.position.set(-5, 5, -5);\n    scene.add(fillLight);\n\n    // Add a simple floor for better lighting visualization\n    const floorGeometry = new THREE.PlaneGeometry(10, 10);\n    const floorMaterial = new THREE.ShadowMaterial({ opacity: 0.3 });\n    const floor = new THREE.Mesh(floorGeometry, floorMaterial);\n    floor.rotation.x = -Math.PI / 2;\n    floor.position.y = -1;\n    floor.receiveShadow = true;\n    scene.add(floor);\n  }, []);\n\n  // Load 3D model\n  const loadModel = useCallback(() => {\n    if (!sceneRef.current) return;\n\n    const loader = new GLTFLoader();\n    \n    // Create a simple placeholder geometry if model fails to load\n    const createPlaceholderModel = () => {\n      const group = new THREE.Group();\n      \n      // Head\n      const headGeometry = new THREE.SphereGeometry(0.5, 32, 32);\n      const headMaterial = new THREE.MeshPhongMaterial({ color: 0xffdbac });\n      const head = new THREE.Mesh(headGeometry, headMaterial);\n      head.position.set(0, 1.5, 0);\n      head.castShadow = true;\n      group.add(head);\n\n      // Body\n      const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.6, 1.2, 32);\n      const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x4169e1 });\n      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);\n      body.position.set(0, 0.5, 0);\n      body.castShadow = true;\n      group.add(body);\n\n      // Eyes\n      const eyeGeometry = new THREE.SphereGeometry(0.1, 16, 16);\n      const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });\n      \n      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);\n      leftEye.position.set(-0.15, 1.6, 0.4);\n      group.add(leftEye);\n\n      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);\n      rightEye.position.set(0.15, 1.6, 0.4);\n      group.add(rightEye);\n\n      // Simple smile\n      const smileGeometry = new THREE.TorusGeometry(0.15, 0.02, 8, 16, Math.PI);\n      const smileMaterial = new THREE.MeshPhongMaterial({ color: 0x000000 });\n      const smile = new THREE.Mesh(smileGeometry, smileMaterial);\n      smile.position.set(0, 1.3, 0.45);\n      smile.rotation.z = Math.PI;\n      group.add(smile);\n\n      group.scale.set(scale, scale, scale);\n      group.position.set(...position);\n      \n      return group;\n    };\n\n    loader.load(\n      modelPath,\n      (gltf) => {\n        const model = gltf.scene;\n        model.scale.set(scale, scale, scale);\n        model.position.set(...position);\n        model.traverse((child) => {\n          if ((child as THREE.Mesh).isMesh) {\n            child.castShadow = true;\n            child.receiveShadow = true;\n          }\n        });\n\n        modelRef.current = model;\n        sceneRef.current.add(model);\n\n        // Setup animations\n        if (gltf.animations.length > 0) {\n          mixerRef.current = new AnimationMixer(model);\n          gltf.animations.forEach((clip) => {\n            mixerRef.current?.clipAction(clip).play();\n          });\n        }\n\n        setIsLoading(false);\n        if (onModelLoaded) onModelLoaded();\n      },\n      (progress) => {\n        // Loading progress\n        const percent = (progress.loaded / progress.total) * 100;\n        console.log(`Loading model: ${percent}%`);\n      },\n      (error) => {\n        console.error(\'Error loading 3D model:\', error);\n        console.log(\'Using placeholder model instead\');\n        \n        // Fallback to placeholder model\n        const placeholderModel = createPlaceholderModel();\n        modelRef.current = placeholderModel;\n        sceneRef.current.add(placeholderModel);\n        \n        setIsLoading(false);\n        setError(null);\n        if (onModelLoaded) onModelLoaded();\n      }\n    );\n  }, [modelPath, scale, position, onModelLoaded]);\n\n  // Handle mouse tracking\n  const handleMouseMove = useCallback((event: MouseEvent) => {\n    if (!mouseTracking || !mountRef.current) return;\n\n    const rect = mountRef.current.getBoundingClientRect();\n    const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n    const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n    \n    setMousePosition({ x, y });\n\n    // Update model head rotation to follow mouse\n    if (modelRef.current) {\n      const headBone = modelRef.current.getObjectByName(\'Head\') || modelRef.current;\n      if (headBone) {\n        headBone.rotation.y = x * 0.3;\n        headBone.rotation.x = y * 0.2;\n      }\n    }\n  }, [mouseTracking]);\n\n  // Apply facial expression\n  const applyFacialExpression = useCallback((expression: FacialExpression) => {\n    if (!modelRef.current) return;\n\n    // This would need to be implemented based on the actual model\'s blend shapes\n    // For now, we\'ll simulate with basic transformations\n    const head = modelRef.current.getObjectByName(\'Head\') || modelRef.current;\n    if (head) {\n      // Simple expression simulation\n      switch (expression.name) {\n        case \'happy\':\n          head.rotation.z = 0.1;\n          break;\n        case \'sad\':\n          head.rotation.z = -0.1;\n          head.position.y = 1.4;\n          break;\n        case \'thinking\':\n          head.rotation.x = 0.1;\n          break;\n        case \'excited\':\n          head.position.y = 1.6;\n          break;\n        default:\n          head.rotation.z = 0;\n          head.position.y = 1.5;\n      }\n    }\n  }, []);\n\n  // Lip sync animation\n  const updateLipSync = useCallback((audioLevel: number) => {\n    if (!modelRef.current || !isSpeaking) return;\n\n    const jaw = modelRef.current.getObjectByName(\'Jaw\') || modelRef.current;\n    if (jaw) {\n      const jawOpen = Math.min(audioLevel * 0.3, 0.5);\n      jaw.rotation.x = jawOpen;\n    }\n  }, [isSpeaking]);\n\n  // Animation loop\n  const animate = useCallback(() => {\n    if (!rendererRef.current || !sceneRef.current || !cameraRef.current) return;\n\n    frameRef.current = requestAnimationFrame(animate);\n\n    const delta = clockRef.current.getDelta();\n\n    // Update animation mixer\n    if (mixerRef.current) {\n      mixerRef.current.update(delta);\n    }\n\n    // Update controls\n    if (controlsRef.current) {\n      controlsRef.current.update();\n    }\n\n    // Auto rotate if enabled\n    if (autoRotate && modelRef.current) {\n      modelRef.current.rotation.y += 0.01;\n    }\n\n    // Update lip sync\n    updateLipSync(audioLevel);\n\n    rendererRef.current.render(sceneRef.current, cameraRef.current);\n  }, [autoRotate, audioLevel, updateLipSync]);\n\n  // Handle window resize\n  const handleResize = useCallback(() => {\n    if (!mountRef.current || !cameraRef.current || !rendererRef.current) return;\n\n    const width = mountRef.current.clientWidth;\n    const height = mountRef.current.clientHeight;\n\n    cameraRef.current.aspect = width / height;\n    cameraRef.current.updateProjectionMatrix();\n    rendererRef.current.setSize(width, height);\n  }, []);\n\n  // Initialize and setup\n  useEffect(() => {\n    initScene();\n    loadModel();\n\n    window.addEventListener(\'resize\', handleResize);\n    window.addEventListener(\'mousemove\', handleMouseMove);\n\n    return () => {\n      window.removeEventListener(\'resize\', handleResize);\n      window.removeEventListener(\'mousemove\', handleMouseMove);\n      \n      if (frameRef.current) {\n        cancelAnimationFrame(frameRef.current);\n      }\n      \n      if (rendererRef.current && mountRef.current) {\n        mountRef.current.removeChild(rendererRef.current.domElement);\n        rendererRef.current.dispose();\n      }\n    };\n  }, [initScene, loadModel, handleResize, handleMouseMove]);\n\n  // Start animation loop\n  useEffect(() => {\n    animate();\n    return () => {\n      if (frameRef.current) {\n        cancelAnimationFrame(frameRef.current);\n      }\n    };\n  }, [animate]);\n\n  // Update emotion\n  useEffect(() => {\n    if (emotion !== currentEmotion) {\n      setCurrentEmotion(emotion);\n      applyFacialExpression(FACIAL_EXPRESSIONS[emotion]);\n    }\n  }, [emotion, currentEmotion, applyFacialExpression]);\n\n  // Update visibility\n  useEffect(() => {\n    setIsModelVisible(isVisible);\n    if (modelRef.current) {\n      modelRef.current.visible = isVisible;\n    }\n  }, [isVisible]);\n\n  return (\n    <div className="relative w-full h-full">\n      {/* 3D Model Container */}\n      <div\n        ref={mountRef}\n        className={`w-full h-full transition-opacity duration-500 ${\n          isModelVisible ? \'opacity-100\' : \'opacity-0\'\n        }`}\n      />\n\n      {/* Loading State */}\n      {isLoading && (\n        <div className="absolute inset-0 flex items-center justify-center bg-gray-100">\n          <div className="text-center">\n            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4"></div>\n            <p className="text-gray-600">Loading Jean 3D Model...</p>\n          </div>\n        </div>\n      )}\n\n      {/* Error State */}\n      {error && (\n        <div className="absolute inset-0 flex items-center justify-center bg-gray-100">\n          <div className="text-center">\n            <p className="text-red-500 mb-4">{error}</p>\n            <button\n              onClick={loadModel}\n              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"\n            >\n              Retry\n            </button>\n          </div>\n        </div>\n      )}\n\n      {/* Controls Overlay */}\n      <div className="absolute top-4 right-4 bg-white rounded-lg shadow-lg p-4 space-y-3">\n        <div className="text-sm font-medium text-gray-900 mb-2">Jean Controls</div>\n        \n        {/* Emotion Selector */}\n        <div className="space-y-2">\n          <div className="text-xs text-gray-600">Emotion</div>\n          <div className="grid grid-cols-3 gap-1">\n            {Object.keys(FACIAL_EXPRESSIONS).map((emo) => (\n              <button\n                key={emo}\n                onClick={() => setCurrentEmotion(emo as any)}\n                className={`p-2 text-xs rounded ${\n                  currentEmotion === emo \n                    ? \'bg-blue-500 text-white\' \n                    : \'bg-gray-100 hover:bg-gray-200\'\n                }`}\n              >\n                {emo === \'neutral\' && <Meh className="w-3 h-3 mx-auto" />}\n                {emo === \'happy\' && <Smile className="w-3 h-3 mx-auto" />}\n                {emo === \'sad\' && <Frown className="w-3 h-3 mx-auto" />}\n                {emo === \'thinking\' && <MessageSquare className="w-3 h-3 mx-auto" />}\n                {emo === \'excited\' && <Zap className="w-3 h-3 mx-auto" />}\n                {emo === \'angry\' && <MessageSquare className="w-3 h-3 mx-auto" />}\n              </button>\n            ))}\n          </div>\n        </div>\n\n        {/* Toggle Controls */}\n        <div className="space-y-2">\n          <div className="text-xs text-gray-600">Options</div>\n          <div className="flex items-center space-x-2">\n            <button\n              onClick={() => setIsModelVisible(!isModelVisible)}\n              className="p-2 text-xs bg-gray-100 hover:bg-gray-200 rounded flex items-center space-x-1"\n            >\n              {isModelVisible ? <Eye className="w-3 h-3" /> : <EyeOff className="w-3 h-3" />}\n              <span>{isModelVisible ? \'Hide\' : \'Show\'}</span>\n            </button>\n          </div>\n          \n          <div className="flex items-center space-x-2">\n            <button\n              className={`p-2 text-xs rounded flex items-center space-x-1 ${\n                mouseTracking ? \'bg-blue-100 text-blue-700\' : \'bg-gray-100 hover:bg-gray-200\'\n              }`}\n            >\n              <MessageSquare className="w-3 h-3" />\n              <span>Mouse Track</span>\n            </button>\n          </div>\n        </div>\n\n        {/* Speaking Indicator */}\n        {isSpeaking && (\n          <div className="flex items-center space-x-2 text-green-600">\n            <Volume2 className="w-4 h-4 animate-pulse" />\n            <span className="text-xs">Speaking</span>\n          </div>\n        )}\n\n        {/* Audio Level Indicator */}\n        {isSpeaking && (\n          <div className="space-y-1">\n            <div className="text-xs text-gray-600">Audio Level</div>\n            <div className="w-full bg-gray-200 rounded-full h-2">\n              <div \n                className="bg-green-500 h-2 rounded-full transition-all duration-100"\n                style={{ width: `${audioLevel * 100}%` }}\n              ></div>\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Status Bar */}\n      <div className="absolute bottom-4 left-4 bg-white rounded-lg shadow-lg px-3 py-2">\n        <div className="flex items-center space-x-3 text-xs">\n          <span className={`px-2 py-1 rounded-full ${\n            isLoading ? \'bg-yellow-100 text-yellow-700\' : \'bg-green-100 text-green-700\'\n          }`}>\n            {isLoading ? \'Loading\' : \'Ready\'}\n          </span>\n          <span className="text-gray-600">\n            Emotion: <span className="font-medium">{currentEmotion}</span>\n          </span>\n          {mouseTracking && (\n            <span className="text-gray-600">\n              Mouse: <span className="font-medium">\n                ({mousePosition.x.toFixed(2)}, {mousePosition.y.toFixed(2)})\n              </span>\n            </span>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Jean3DModel;\n</create-file>\n</function_calls>'}