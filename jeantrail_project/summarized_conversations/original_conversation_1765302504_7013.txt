{'role': 'assistant', 'content': '\n<function_calls>\n<create-file file_path="src/hooks/useDashboard.ts">\nimport { useState, useEffect, useCallback } from \'react\';\nimport { useUIStore } from \'@/store\';\nimport { ServiceStatus, SystemMetrics, Task } from \'@/types\';\n\nexport const useDashboard = () => {\n  const { language } = useUIStore();\n  const [services, setServices] = useState<ServiceStatus[]>([]);\n  const [metrics, setMetrics] = useState<SystemMetrics>({\n    cpu: 0,\n    memory: 0,\n    disk: 0,\n    network: 0,\n    gpu: 0,\n  });\n  const [tasks, setTasks] = useState<Task[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [refreshInterval, setRefreshInterval] = useState(5000); // 5 seconds\n\n  const isRTL = language === \'ar\';\n\n  // Fetch service statuses\n  const fetchServiceStatuses = useCallback(async () => {\n    try {\n      const response = await fetch(\'/api/dashboard/services\');\n      if (response.ok) {\n        const data = await response.json();\n        setServices(data);\n      }\n    } catch (error) {\n      console.error(\'Failed to fetch service statuses:\', error);\n    }\n  }, []);\n\n  // Fetch system metrics\n  const fetchSystemMetrics = useCallback(async () => {\n    try {\n      const response = await fetch(\'/api/dashboard/metrics\');\n      if (response.ok) {\n        const data = await response.json();\n        setMetrics(data);\n      }\n    } catch (error) {\n      console.error(\'Failed to fetch system metrics:\', error);\n    }\n  }, []);\n\n  // Fetch active tasks\n  const fetchTasks = useCallback(async () => {\n    try {\n      const response = await fetch(\'/api/dashboard/tasks\');\n      if (response.ok) {\n        const data = await response.json();\n        setTasks(data);\n      }\n    } catch (error) {\n      console.error(\'Failed to fetch tasks:\', error);\n    }\n  }, []);\n\n  // Initialize dashboard data\n  const initializeDashboard = useCallback(async () => {\n    setIsLoading(true);\n    try {\n      await Promise.all([\n        fetchServiceStatuses(),\n        fetchSystemMetrics(),\n        fetchTasks(),\n      ]);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [fetchServiceStatuses, fetchSystemMetrics, fetchTasks]);\n\n  // Refresh all data\n  const refreshData = useCallback(async () => {\n    await initializeDashboard();\n  }, [initializeDashboard]);\n\n  // Start/stop service\n  const toggleService = useCallback(async (serviceName: string) => {\n    try {\n      const response = await fetch(`/api/dashboard/services/${serviceName}/toggle`, {\n        method: \'POST\',\n      });\n      \n      if (response.ok) {\n        await fetchServiceStatuses();\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error(\'Failed to toggle service:\', error);\n      return false;\n    }\n  }, [fetchServiceStatuses]);\n\n  // Cancel task\n  const cancelTask = useCallback(async (taskId: string) => {\n    try {\n      const response = await fetch(`/api/dashboard/tasks/${taskId}/cancel`, {\n        method: \'POST\',\n      });\n      \n      if (response.ok) {\n        await fetchTasks();\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error(\'Failed to cancel task:\', error);\n      return false;\n    }\n  }, [fetchTasks]);\n\n  // Restart service\n  const restartService = useCallback(async (serviceName: string) => {\n    try {\n      const response = await fetch(`/api/dashboard/services/${serviceName}/restart`, {\n        method: \'POST\',\n      });\n      \n      if (response.ok) {\n        await fetchServiceStatuses();\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error(\'Failed to restart service:\', error);\n      return false;\n    }\n  }, [fetchServiceStatuses]);\n\n  // Get service status color\n  const getServiceStatusColor = useCallback((status: string) => {\n    switch (status) {\n      case \'online\':\n        return \'text-green-500\';\n      case \'offline\':\n        return \'text-red-500\';\n      case \'loading\':\n        return \'text-yellow-500\';\n      default:\n        return \'text-gray-500\';\n    }\n  }, []);\n\n  // Get task status color\n  const getTaskStatusColor = useCallback((status: string) => {\n    switch (status) {\n      case \'completed\':\n        return \'text-green-500\';\n      case \'running\':\n        return \'text-blue-500\';\n      case \'failed\':\n        return \'text-red-500\';\n      case \'pending\':\n        return \'text-yellow-500\';\n      default:\n        return \'text-gray-500\';\n    }\n  }, []);\n\n  // Format bytes\n  const formatBytes = useCallback((bytes: number, decimals = 2) => {\n    if (bytes === 0) return \'0 Bytes\';\n\n    const k = 1024;\n    const dm = decimals < 0 ? 0 : decimals;\n    const sizes = [\'Bytes\', \'KB\', \'MB\', \'GB\', \'TB\', \'PB\', \'EB\', \'ZB\', \'YB\'];\n\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + \' \' + sizes[i];\n  }, []);\n\n  // Calculate system health\n  const getSystemHealth = useCallback(() => {\n    const onlineServices = services.filter(s => s.status === \'online\').length;\n    const totalServices = services.length;\n    const failedTasks = tasks.filter(t => t.status === \'failed\').length;\n    const runningTasks = tasks.filter(t => t.status === \'running\').length;\n    \n    let healthScore = 100;\n    \n    // Deduct points for offline services\n    if (totalServices > 0) {\n      healthScore -= ((totalServices - onlineServices) / totalServices) * 40;\n    }\n    \n    // Deduct points for failed tasks\n    if (tasks.length > 0) {\n      healthScore -= (failedTasks / tasks.length) * 30;\n    }\n    \n    // Deduct points for high resource usage\n    if (metrics.cpu > 90) healthScore -= 10;\n    if (metrics.memory > 90) healthScore -= 10;\n    if (metrics.disk > 90) healthScore -= 10;\n    \n    return Math.max(0, Math.round(healthScore));\n  }, [services, tasks, metrics]);\n\n  // Get metrics trend (mock implementation)\n  const getMetricsTrend = useCallback((metric: keyof SystemMetrics) => {\n    // In a real implementation, this would compare with historical data\n    const trends = {\n      cpu: \'up\',\n      memory: \'stable\',\n      disk: \'up\',\n      network: \'down\',\n      gpu: \'stable\',\n    };\n    \n    return trends[metric] || \'stable\';\n  }, []);\n\n  // Initialize on mount\n  useEffect(() => {\n    initializeDashboard();\n  }, [initializeDashboard]);\n\n  // Set up auto-refresh\n  useEffect(() => {\n    const interval = setInterval(() => {\n      refreshData();\n    }, refreshInterval);\n\n    return () => clearInterval(interval);\n  }, [refreshData, refreshInterval]);\n\n  // Auto-refresh interval management\n  useEffect(() => {\n    // Increase refresh interval when tab is not visible\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        setRefreshInterval(30000); // 30 seconds\n      } else {\n        setRefreshInterval(5000); // 5 seconds\n      }\n    };\n\n    document.addEventListener(\'visibilitychange\', handleVisibilityChange);\n    return () => document.removeEventListener(\'visibilitychange\', handleVisibilityChange);\n  }, []);\n\n  return {\n    // State\n    services,\n    metrics,\n    tasks,\n    isLoading,\n    refreshInterval,\n\n    // Computed values\n    systemHealth: getSystemHealth(),\n    onlineServicesCount: services.filter(s => s.status === \'online\').length,\n    runningTasksCount: tasks.filter(t => t.status === \'running\').length,\n    failedTasksCount: tasks.filter(t => t.status === \'failed\').length,\n\n    // Actions\n    refreshData,\n    toggleService,\n    cancelTask,\n    restartService,\n    setRefreshInterval,\n\n    // Utilities\n    getServiceStatusColor,\n    getTaskStatusColor,\n    formatBytes,\n    getMetricsTrend,\n  };\n};\n</create-file>\n</function_calls>'}