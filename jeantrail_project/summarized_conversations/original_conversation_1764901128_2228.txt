{'role': 'assistant', 'content': '\n<function_calls>\n<create-file file_path="src/services/portfolio.ts">\n// Portfolio Aggregator Service Interface and Implementation\nexport interface Portfolio {\n  id: string;\n  userId: string;\n  name: string;\n  description?: string;\n  accounts: Account[];\n  totalValue: number;\n  baseCurrency: string;\n  lastUpdated: Date;\n  createdAt: Date;\n  settings: PortfolioSettings;\n}\n\nexport interface Account {\n  id: string;\n  institutionId: string;\n  institutionName: string;\n  type: AccountType;\n  name: string;\n  balance: number;\n  currency: string;\n  balanceInBaseCurrency: number;\n  holdings: Holding[];\n  isActive: boolean;\n  lastSync: Date;\n  syncStatus: \'success\' | \'pending\' | \'error\';\n  metadata: AccountMetadata;\n}\n\nexport type AccountType = \n  | \'checking\'\n  | \'savings\'\n  | \'credit_card\'\n  | \'investment\'\n  | \'retirement\'\n  | \'crypto\'\n  | \'loan\'\n  | \'mortgage\'\n  | \'property\'\n  | \'other\';\n\nexport interface Holding {\n  id: string;\n  symbol: string;\n  name: string;\n  quantity: number;\n  averageCost: number;\n  currentPrice: number;\n  currentPriceInBaseCurrency: number;\n  marketValue: number;\n  marketValueInBaseCurrency: number;\n  unrealizedGainLoss: number;\n  unrealizedGainLossPercentage: number;\n  assetClass: AssetClass;\n  sector?: string;\n  region?: string;\n  lastPriceUpdate: Date;\n}\n\nexport type AssetClass = \n  | \'stocks\'\n  | \'bonds\'\n  | \'real_estate\'\n  | \'commodities\'\n  | \'crypto\'\n  | \'cash\'\n  | \'alternative\'\n  | \'other\';\n\nexport interface AccountMetadata {\n  accountNumber?: string;\n  routingNumber?: string;\n  interestRate?: number;\n  creditLimit?: number;\n  availableCredit?: number;\n  nextPaymentDate?: Date;\n  minimumPayment?: number;\n  accountOpenDate?: Date;\n  maturityDate?: Date;\n}\n\nexport interface PortfolioSettings {\n  autoSync: boolean;\n  syncFrequency: number; // in hours\n  alertThresholds: AlertThresholds;\n  privacy: PrivacySettings;\n  display: DisplaySettings;\n}\n\nexport interface AlertThresholds {\n  priceChange: number; // percentage\n  balanceChange: number; // amount\n  newTransaction: number; // amount\n  accountLowBalance: number; // amount\n  creditCardHighUsage: number; // percentage\n}\n\nexport interface PrivacySettings {\n  shareAnonymousData: boolean;\n  showNetWorth: boolean;\n  showAccountDetails: boolean;\n  showTransactions: boolean;\n}\n\nexport interface DisplaySettings {\n  defaultCurrency: string;\n  showPercentages: boolean;\n  showAbsoluteValues: boolean;\n  defaultTimeRange: TimeRange;\n  chartType: \'line\' | \'bar\' | \'pie\' | \'area\';\n}\n\nexport type TimeRange = \'1D\' | \'1W\' | \'1M\' | \'3M\' | \'6M\' | \'1Y\' | \'3Y\' | \'5Y\' | \'ALL\';\n\nexport interface Transaction {\n  id: string;\n  accountId: string;\n  accountName: string;\n  type: TransactionType;\n  amount: number;\n  currency: string;\n  amountInBaseCurrency: number;\n  description: string;\n  category?: string;\n  date: Date;\n  balance?: number;\n  pending: boolean;\n  metadata: TransactionMetadata;\n}\n\nexport type TransactionType = \n  | \'deposit\'\n  | \'withdrawal\'\n  | \'purchase\'\n  | \'sale\'\n  | \'transfer_in\'\n  | \'transfer_out\'\n  | \'dividend\'\n  | \'interest\'\n  | \'fee\'\n  | \'payment\'\n  | \'refund\'\n  | \'other\';\n\nexport interface TransactionMetadata {\n  merchant?: string;\n  location?: string;\n  reference?: string;\n  tags?: string[];\n  attachments?: string[];\n  recurring?: boolean;\n  frequency?: \'daily\' | \'weekly\' | \'monthly\' | \'yearly\';\n}\n\nexport interface PerformanceMetrics {\n  totalReturn: number;\n  totalReturnPercentage: number;\n  annualizedReturn: number;\n  volatility: number;\n  sharpeRatio: number;\n  maxDrawdown: number;\n  alpha?: number;\n  beta?: number;\n  timeWeightedReturn: number;\n  moneyWeightedReturn: number;\n}\n\nexport interface AssetAllocation {\n  assetClass: AssetClass;\n  value: number;\n  percentage: number;\n  targetPercentage?: number;\n  deviation: number;\n  holdings: Holding[];\n}\n\nexport interface Institution {\n  id: string;\n  name: string;\n  logo?: string;\n  website?: string;\n  supportedAccountTypes: AccountType[];\n  connectionMethod: \'plaid\' | \'ofx\' | \'api\' | \'manual\';\n  features: InstitutionFeatures;\n  isActive: boolean;\n}\n\nexport interface InstitutionFeatures {\n  realTimeData: boolean;\n  historicalData: boolean;\n  transactions: boolean;\n  transfers: boolean;\n  billPay: boolean;\n  investments: boolean;\n}\n\nexport interface PortfolioAggregatorService {\n  // Portfolio management\n  getPortfolios: () => Promise<Portfolio[]>;\n  getPortfolio: (id: string) => Promise<Portfolio>;\n  createPortfolio: (portfolio: Omit<Portfolio, \'id\' | \'createdAt\' | \'lastUpdated\'>) => Promise<Portfolio>;\n  updatePortfolio: (id: string, updates: Partial<Portfolio>) => Promise<Portfolio>;\n  deletePortfolio: (id: string) => Promise<void>;\n  \n  // Account management\n  getAccounts: (portfolioId?: string) => Promise<Account[]>;\n  getAccount: (id: string) => Promise<Account>;\n  addAccount: (portfolioId: string, institutionId: string, credentials: AccountCredentials) => Promise<Account>;\n  updateAccount: (id: string, updates: Partial<Account>) => Promise<Account>;\n  removeAccount: (id: string) => Promise<void>;\n  syncAccount: (id: string) => Promise<Account>;\n  syncAllAccounts: (portfolioId?: string) => Promise<void>;\n  \n  // Institution management\n  getInstitutions: () => Promise<Institution[]>;\n  getInstitution: (id: string) => Promise<Institution>;\n  searchInstitutions: (query: string) => Promise<Institution[]>;\n  \n  // Transactions\n  getTransactions: (accountId?: string, filters?: TransactionFilters) => Promise<Transaction[]>;\n  getTransaction: (id: string) => Promise<Transaction>;\n  categorizeTransaction: (transactionId: string, category: string) => Promise<void>;\n  addTransactionTag: (transactionId: string, tag: string) => Promise<void>;\n  removeTransactionTag: (transactionId: string, tag: string) => Promise<void>;\n  \n  // Holdings and performance\n  getHoldings: (portfolioId?: string) => Promise<Holding[]>;\n  getHolding: (id: string) => Promise<Holding>;\n  getPerformanceMetrics: (portfolioId: string, timeRange?: TimeRange) => Promise<PerformanceMetrics>;\n  getHistoricalPerformance: (portfolioId: string, timeRange: TimeRange) => Promise<PerformanceDataPoint[]>;\n  \n  // Asset allocation\n  getAssetAllocation: (portfolioId: string) => Promise<AssetAllocation[]>;\n  getTargetAssetAllocation: (portfolioId: string) => Promise<AssetAllocation[]>;\n  setTargetAssetAllocation: (portfolioId: string, allocation: Omit<AssetAllocation, \'value\' | \'percentage\' | \'deviation\' | \'holdings\'>[]) => Promise<void>;\n  getRebalancingRecommendations: (portfolioId: string) => Promise<RebalancingRecommendation[]>;\n  \n  // Analytics and insights\n  getPortfolioSummary: (portfolioId: string) => Promise<PortfolioSummary>;\n  getSpendingAnalysis: (portfolioId: string, timeRange?: TimeRange) => Promise<SpendingAnalysis>;\n  getNetWorthTrend: (portfolioId: string, timeRange: TimeRange) => Promise<NetWorthDataPoint[]>;\n  getIncomeAnalysis: (portfolioId: string, timeRange?: TimeRange) => Promise<IncomeAnalysis>;\n  getExpenseAnalysis: (portfolioId: string, timeRange?: TimeRange) => Promise<ExpenseAnalysis>;\n  \n  // Goals and planning\n  getGoals: (portfolioId: string) => Promise<FinancialGoal[]>;\n  createGoal: (portfolioId: string, goal: Omit<FinancialGoal, \'id\' | \'createdAt\'>) => Promise<FinancialGoal>;\n  updateGoal: (id: string, updates: Partial<FinancialGoal>) => Promise<FinancialGoal>;\n  deleteGoal: (id: string) => Promise<void>;\n  getGoalProgress: (goalId: string) => Promise<GoalProgress>;\n  \n  // Alerts and notifications\n  getAlerts: (portfolioId?: string) => Promise<Alert[]>;\n  createAlert: (alert: Omit<Alert, \'id\' | \'createdAt\'>) => Promise<Alert>;\n  updateAlert: (id: string, updates: Partial<Alert>) => Promise<Alert>;\n  deleteAlert: (id: string) => Promise<void>;\n  \n  // Reports and exports\n  generateReport: (portfolioId: string, reportType: ReportType, filters?: ReportFilters) => Promise<Report>;\n  exportData: (portfolioId: string, format: \'csv\' | \'json\' | \'pdf\', filters?: ExportFilters) => Promise<Blob>;\n  \n  // Budget management\n  getBudgets: (portfolioId: string) => Promise<Budget[]>;\n  createBudget: (portfolioId: string, budget: Omit<Budget, \'id\' | \'createdAt\'>) => Promise<Budget>;\n  updateBudget: (id: string, updates: Partial<Budget>) => Promise<Budget>;\n  deleteBudget: (id: string) => Promise<void>;\n  getBudgetPerformance: (budgetId: string, timeRange?: TimeRange) => Promise<BudgetPerformance>;\n}\n\nexport interface AccountCredentials {\n  username?: string;\n  password?: string;\n  apiKey?: string;\n  accessToken?: string;\n  accountId?: string;\n  // Additional institution-specific credentials\n  [key: string]: any;\n}\n\nexport interface TransactionFilters {\n  type?: TransactionType[];\n  category?: string[];\n  dateRange?: {\n    from: Date;\n    to: Date;\n  };\n  amountRange?: {\n    min: number;\n    max: number;\n  };\n  search?: string;\n  tags?: string[];\n}\n\nexport interface PerformanceDataPoint {\n  date: Date;\n  value: number;\n  return?: number;\n}\n\nexport interface RebalancingRecommendation {\n  assetClass: AssetClass;\n  currentAllocation: number;\n  targetAllocation: number;\n  difference: number;\n  action: \'buy\' | \'sell\';\n  amount: number;\n  percentage: number;\n}\n\nexport interface PortfolioSummary {\n  totalNetWorth: number;\n  totalAssets: number;\n  totalLiabilities: number;\n  cashBalance: number;\n  investmentValue: number;\n  realEstateValue: number;\n  monthlyIncome: number;\n  monthlyExpenses: number;\n  savingsRate: number;\n  debtToIncomeRatio: number;\n  emergencyFundMonths: number;\n  retirementProgress: number;\n  netWorthChange: {\n    amount: number;\n    percentage: number;\n    period: TimeRange;\n  };\n}\n\nexport interface SpendingAnalysis {\n  totalSpending: number;\n  spendingByCategory: CategorySpending[];\n  spendingByMonth: MonthlySpending[];\n  topExpenses: Transaction[];\n  averageDailySpending: number;\n  budgetVariance: BudgetVariance[];\n}\n\nexport interface CategorySpending {\n  category: string;\n  amount: number;\n  percentage: number;\n  transactionCount: number;\n  averageTransaction: number;\n  trend: \'up\' | \'down\' | \'stable\';\n}\n\nexport interface MonthlySpending {\n  month: string;\n  amount: number;\n  change: number;\n  changePercentage: number;\n}\n\nexport interface BudgetVariance {\n  category: string;\n  budgeted: number;\n  actual: number;\n  variance: number;\n  variancePercentage: number;\n}\n\nexport interface NetWorthDataPoint {\n  date: Date;\n  netWorth: number;\n  assets: number;\n  liabilities: number;\n}\n\nexport interface IncomeAnalysis {\n  totalIncome: number;\n  incomeBySource: IncomeSource[];\n  incomeTrend: MonthlyIncome[];\n  averageMonthlyIncome: number;\n  yearToDateIncome: number;\n  projectedAnnualIncome: number;\n}\n\nexport interface IncomeSource {\n  source: string;\n  amount: number;\n  percentage: number;\n  frequency: \'monthly\' | \'quarterly\' | \'annual\' | \'irregular\';\n  stability: \'stable\' | \'variable\' | \'uncertain\';\n}\n\nexport interface MonthlyIncome {\n  month: string;\n  amount: number;\n  change: number;\n  changePercentage: number;\n}\n\nexport interface ExpenseAnalysis {\n  totalExpenses: number;\n  expensesByCategory: CategoryExpenses[];\n  fixedVsVariable: {\n    fixed: number;\n    variable: number;\n    percentage: number;\n  };\n  expensesTrend: MonthlyExpenses[];\n  averageMonthlyExpenses: number;\n  largestExpenseCategories: string[];\n}\n\nexport interface CategoryExpenses {\n  category: string;\n  amount: number;\n  percentage: number;\n  transactionCount: number;\n  trend: \'up\' | \'down\' | \'stable\';\n}\n\nexport interface MonthlyExpenses {\n  month: string;\n  amount: number;\n  change: number;\n  changePercentage: number;\n}\n\nexport interface FinancialGoal {\n  id: string;\n  portfolioId: string;\n  name: string;\n  description?: string;\n  type: GoalType;\n  targetAmount: number;\n  currentAmount: number;\n  targetDate: Date;\n  priority: \'low\' | \'medium\' | \'high\';\n  status: \'active\' | \'completed\' | \'paused\' | \'cancelled\';\n  autoContribution: boolean;\n  contributionAmount: number;\n  contributionFrequency: \'weekly\' | \'monthly\' | \'quarterly\' | \'yearly\';\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport type GoalType = \n  | \'retirement\'\n  | \'emergency_fund\'\n  | \'house_purchase\'\n  | \'education\'\n  | \'car_purchase\'\n  | \'vacation\'\n  | \'debt_payoff\'\n  | \'investment\'\n  | \'savings\'\n  | \'other\';\n\nexport interface GoalProgress {\n  goalId: string;\n  currentAmount: number;\n  targetAmount: number;\n  percentageComplete: number;\n  amountRemaining: number;\n  timeRemaining: number; // in days\n  onTrack: boolean;\n  projectedCompletionDate: Date;\n  monthlyContributionNeeded: number;\n  recommendations: string[];\n}\n\nexport interface Alert {\n  id: string;\n  portfolioId?: string;\n  accountId?: string;\n  type: AlertType;\n  title: string;\n  message: string;\n  severity: \'low\' | \'medium\' | \'high\' | \'critical\';\n  isRead: boolean;\n  isActive: boolean;\n  triggeredAt?: Date;\n  createdAt: Date;\n  conditions: AlertCondition[];\n}\n\nexport type AlertType = \n  | \'balance_threshold\'\n  | \'transaction_amount\'\n  | \'price_change\'\n  | \'goal_progress\'\n  | \'budget_variance\'\n  | \'account_sync_error\'\n  | \'market_event\'\n  | \'rebalancing_needed\'\n  | \'other\';\n\nexport interface AlertCondition {\n  field: string;\n  operator: \'greater_than\' | \'less_than\' | \'equals\' | \'not_equals\' | \'percentage_change\';\n  value: any;\n  description: string;\n}\n\nexport type ReportType = \n  | \'portfolio_summary\'\n  | \'performance_report\'\n  | \'asset_allocation\'\n  | \'income_expense\'\n  | \'net_worth_trend\'\n  | \'tax_summary\'\n  | \'investment_analysis\'\n  | \'custom\';\n\nexport interface ReportFilters {\n  dateRange?: TimeRange;\n  accounts?: string[];\n  categories?: string[];\n  includeCharts?: boolean;\n  includeDetails?: boolean;\n}\n\nexport interface Report {\n  id: string;\n  type: ReportType;\n  title: string;\n  generatedAt: Date;\n  period: {\n    from: Date;\n    to: Date;\n  };\n  data: any;\n  charts?: ChartData[];\n  summary: string;\n}\n\nexport interface ChartData {\n  type: \'line\' | \'bar\' | \'pie\' | \'area\';\n  title: string;\n  data: any[];\n  xAxis?: string;\n  yAxis?: string;\n}\n\nexport interface ExportFilters {\n  dateRange?: {\n    from: Date;\n    to: Date;\n  };\n  accounts?: string[];\n  includeTransactions?: boolean;\n  includeHoldings?: boolean;\n  includePerformance?: boolean;\n}\n\nexport interface Budget {\n  id: string;\n  portfolioId: string;\n  name: string;\n  category: string;\n  amount: number;\n  period: \'weekly\' | \'monthly\' | \'quarterly\' | \'yearly\';\n  startDate: Date;\n  endDate?: Date;\n  spent: number;\n  remaining: number;\n  percentageUsed: number;\n  isActive: boolean;\n  alertThreshold?: number;\n  createdAt: Date;\n}\n\nexport interface BudgetPerformance {\n  budgetId: string;\n  period: string;\n  budgeted: number;\n  actual: number;\n  variance: number;\n  variancePercentage: number;\n  onTrack: boolean;\n  dailyAverageSpending: number;\n  projectedSpending: number;\n  recommendations: string[];\n}\n\nclass PortfolioAggregatorServiceImpl implements PortfolioAggregatorService {\n  private baseUrl: string;\n\n  constructor(baseUrl: string = \'http://localhost:8080\') {\n    this.baseUrl = baseUrl;\n  }\n\n  async getPortfolios(): Promise<Portfolio[]> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios`);\n    if (!response.ok) throw new Error(\'Failed to get portfolios\');\n    return response.json();\n  }\n\n  async getPortfolio(id: string): Promise<Portfolio> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${id}`);\n    if (!response.ok) throw new Error(\'Failed to get portfolio\');\n    return response.json();\n  }\n\n  async createPortfolio(portfolio: Omit<Portfolio, \'id\' | \'createdAt\' | \'lastUpdated\'>): Promise<Portfolio> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios`, {\n      method: \'POST\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify(portfolio),\n    });\n    if (!response.ok) throw new Error(\'Failed to create portfolio\');\n    return response.json();\n  }\n\n  async updatePortfolio(id: string, updates: Partial<Portfolio>): Promise<Portfolio> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${id}`, {\n      method: \'PUT\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify(updates),\n    });\n    if (!response.ok) throw new Error(\'Failed to update portfolio\');\n    return response.json();\n  }\n\n  async deletePortfolio(id: string): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${id}`, {\n      method: \'DELETE\',\n    });\n    if (!response.ok) throw new Error(\'Failed to delete portfolio\');\n  }\n\n  async getAccounts(portfolioId?: string): Promise<Account[]> {\n    const params = portfolioId ? `?portfolioId=${portfolioId}` : \'\';\n    const response = await fetch(`${this.baseUrl}/api/portfolio/accounts${params}`);\n    if (!response.ok) throw new Error(\'Failed to get accounts\');\n    return response.json();\n  }\n\n  async getAccount(id: string): Promise<Account> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/accounts/${id}`);\n    if (!response.ok) throw new Error(\'Failed to get account\');\n    return response.json();\n  }\n\n  async addAccount(portfolioId: string, institutionId: string, credentials: AccountCredentials): Promise<Account> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${portfolioId}/accounts`, {\n      method: \'POST\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify({ institutionId, credentials }),\n    });\n    if (!response.ok) throw new Error(\'Failed to add account\');\n    return response.json();\n  }\n\n  async updateAccount(id: string, updates: Partial<Account>): Promise<Account> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/accounts/${id}`, {\n      method: \'PUT\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify(updates),\n    });\n    if (!response.ok) throw new Error(\'Failed to update account\');\n    return response.json();\n  }\n\n  async removeAccount(id: string): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/accounts/${id}`, {\n      method: \'DELETE\',\n    });\n    if (!response.ok) throw new Error(\'Failed to remove account\');\n  }\n\n  async syncAccount(id: string): Promise<Account> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/accounts/${id}/sync`, {\n      method: \'POST\',\n    });\n    if (!response.ok) throw new Error(\'Failed to sync account\');\n    return response.json();\n  }\n\n  async syncAllAccounts(portfolioId?: string): Promise<void> {\n    const params = portfolioId ? `?portfolioId=${portfolioId}` : \'\';\n    const response = await fetch(`${this.baseUrl}/api/portfolio/accounts/sync-all${params}`, {\n      method: \'POST\',\n    });\n    if (!response.ok) throw new Error(\'Failed to sync all accounts\');\n  }\n\n  async getInstitutions(): Promise<Institution[]> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/institutions`);\n    if (!response.ok) throw new Error(\'Failed to get institutions\');\n    return response.json();\n  }\n\n  async getInstitution(id: string): Promise<Institution> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/institutions/${id}`);\n    if (!response.ok) throw new Error(\'Failed to get institution\');\n    return response.json();\n  }\n\n  async searchInstitutions(query: string): Promise<Institution[]> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/institutions/search?q=${encodeURIComponent(query)}`);\n    if (!response.ok) throw new Error(\'Failed to search institutions\');\n    return response.json();\n  }\n\n  async getTransactions(accountId?: string, filters?: TransactionFilters): Promise<Transaction[]> {\n    const params = new URLSearchParams();\n    if (accountId) params.append(\'accountId\', accountId);\n    if (filters) {\n      Object.entries(filters).forEach(([key, value]) => {\n        if (value !== undefined) {\n          if (Array.isArray(value)) {\n            value.forEach(v => params.append(key, v));\n          } else if (typeof value === \'object\') {\n            Object.entries(value).forEach(([subKey, subValue]) => {\n              params.append(`${key}.${subKey}`, String(subValue));\n            });\n          } else {\n            params.append(key, String(value));\n          }\n        }\n      });\n    }\n\n    const response = await fetch(`${this.baseUrl}/api/portfolio/transactions?${params}`);\n    if (!response.ok) throw new Error(\'Failed to get transactions\');\n    return response.json();\n  }\n\n  async getTransaction(id: string): Promise<Transaction> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/transactions/${id}`);\n    if (!response.ok) throw new Error(\'Failed to get transaction\');\n    return response.json();\n  }\n\n  async categorizeTransaction(transactionId: string, category: string): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/transactions/${transactionId}/category`, {\n      method: \'PUT\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify({ category }),\n    });\n    if (!response.ok) throw new Error(\'Failed to categorize transaction\');\n  }\n\n  async addTransactionTag(transactionId: string, tag: string): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/transactions/${transactionId}/tags`, {\n      method: \'POST\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify({ tag }),\n    });\n    if (!response.ok) throw new Error(\'Failed to add transaction tag\');\n  }\n\n  async removeTransactionTag(transactionId: string, tag: string): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/transactions/${transactionId}/tags/${tag}`, {\n      method: \'DELETE\',\n    });\n    if (!response.ok) throw new Error(\'Failed to remove transaction tag\');\n  }\n\n  async getHoldings(portfolioId?: string): Promise<Holding[]> {\n    const params = portfolioId ? `?portfolioId=${portfolioId}` : \'\';\n    const response = await fetch(`${this.baseUrl}/api/portfolio/holdings${params}`);\n    if (!response.ok) throw new Error(\'Failed to get holdings\');\n    return response.json();\n  }\n\n  async getHolding(id: string): Promise<Holding> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/holdings/${id}`);\n    if (!response.ok) throw new Error(\'Failed to get holding\');\n    return response.json();\n  }\n\n  async getPerformanceMetrics(portfolioId: string, timeRange?: TimeRange): Promise<PerformanceMetrics> {\n    const params = timeRange ? `?timeRange=${timeRange}` : \'\';\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${portfolioId}/performance${params}`);\n    if (!response.ok) throw new Error(\'Failed to get performance metrics\');\n    return response.json();\n  }\n\n  async getHistoricalPerformance(portfolioId: string, timeRange: TimeRange): Promise<PerformanceDataPoint[]> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${portfolioId}/performance/history?timeRange=${timeRange}`);\n    if (!response.ok) throw new Error(\'Failed to get historical performance\');\n    return response.json();\n  }\n\n  async getAssetAllocation(portfolioId: string): Promise<AssetAllocation[]> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${portfolioId}/allocation`);\n    if (!response.ok) throw new Error(\'Failed to get asset allocation\');\n    return response.json();\n  }\n\n  async getTargetAssetAllocation(portfolioId: string): Promise<AssetAllocation[]> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${portfolioId}/allocation/target`);\n    if (!response.ok) throw new Error(\'Failed to get target asset allocation\');\n    return response.json();\n  }\n\n  async setTargetAssetAllocation(portfolioId: string, allocation: Omit<AssetAllocation, \'value\' | \'percentage\' | \'deviation\' | \'holdings\'>[]): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${portfolioId}/allocation/target`, {\n      method: \'PUT\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify({ allocation }),\n    });\n    if (!response.ok) throw new Error(\'Failed to set target asset allocation\');\n  }\n\n  async getRebalancingRecommendations(portfolioId: string): Promise<RebalancingRecommendation[]> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${portfolioId}/rebalancing`);\n    if (!response.ok) throw new Error(\'Failed to get rebalancing recommendations\');\n    return response.json();\n  }\n\n  async getPortfolioSummary(portfolioId: string): Promise<PortfolioSummary> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${portfolioId}/summary`);\n    if (!response.ok) throw new Error(\'Failed to get portfolio summary\');\n    return response.json();\n  }\n\n  async getSpendingAnalysis(portfolioId: string, timeRange?: TimeRange): Promise<SpendingAnalysis> {\n    const params = timeRange ? `?timeRange=${timeRange}` : \'\';\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${portfolioId}/analysis/spending${params}`);\n    if (!response.ok) throw new Error(\'Failed to get spending analysis\');\n    return response.json();\n  }\n\n  async getNetWorthTrend(portfolioId: string, timeRange: TimeRange): Promise<NetWorthDataPoint[]> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${portfolioId}/net-worth/trend?timeRange=${timeRange}`);\n    if (!response.ok) throw new Error(\'Failed to get net worth trend\');\n    return response.json();\n  }\n\n  async getIncomeAnalysis(portfolioId: string, timeRange?: TimeRange): Promise<IncomeAnalysis> {\n    const params = timeRange ? `?timeRange=${timeRange}` : \'\';\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${portfolioId}/analysis/income${params}`);\n    if (!response.ok) throw new Error(\'Failed to get income analysis\');\n    return response.json();\n  }\n\n  async getExpenseAnalysis(portfolioId: string, timeRange?: TimeRange): Promise<ExpenseAnalysis> {\n    const params = timeRange ? `?timeRange=${timeRange}` : \'\';\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${portfolioId}/analysis/expenses${params}`);\n    if (!response.ok) throw new Error(\'Failed to get expense analysis\');\n    return response.json();\n  }\n\n  async getGoals(portfolioId: string): Promise<FinancialGoal[]> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${portfolioId}/goals`);\n    if (!response.ok) throw new Error(\'Failed to get goals\');\n    return response.json();\n  }\n\n  async createGoal(portfolioId: string, goal: Omit<FinancialGoal, \'id\' | \'createdAt\'>): Promise<FinancialGoal> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${portfolioId}/goals`, {\n      method: \'POST\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify(goal),\n    });\n    if (!response.ok) throw new Error(\'Failed to create goal\');\n    return response.json();\n  }\n\n  async updateGoal(id: string, updates: Partial<FinancialGoal>): Promise<FinancialGoal> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/goals/${id}`, {\n      method: \'PUT\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify(updates),\n    });\n    if (!response.ok) throw new Error(\'Failed to update goal\');\n    return response.json();\n  }\n\n  async deleteGoal(id: string): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/goals/${id}`, {\n      method: \'DELETE\',\n    });\n    if (!response.ok) throw new Error(\'Failed to delete goal\');\n  }\n\n  async getGoalProgress(goalId: string): Promise<GoalProgress> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/goals/${goalId}/progress`);\n    if (!response.ok) throw new Error(\'Failed to get goal progress\');\n    return response.json();\n  }\n\n  async getAlerts(portfolioId?: string): Promise<Alert[]> {\n    const params = portfolioId ? `?portfolioId=${portfolioId}` : \'\';\n    const response = await fetch(`${this.baseUrl}/api/portfolio/alerts${params}`);\n    if (!response.ok) throw new Error(\'Failed to get alerts\');\n    return response.json();\n  }\n\n  async createAlert(alert: Omit<Alert, \'id\' | \'createdAt\'>): Promise<Alert> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/alerts`, {\n      method: \'POST\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify(alert),\n    });\n    if (!response.ok) throw new Error(\'Failed to create alert\');\n    return response.json();\n  }\n\n  async updateAlert(id: string, updates: Partial<Alert>): Promise<Alert> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/alerts/${id}`, {\n      method: \'PUT\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify(updates),\n    });\n    if (!response.ok) throw new Error(\'Failed to update alert\');\n    return response.json();\n  }\n\n  async deleteAlert(id: string): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/alerts/${id}`, {\n      method: \'DELETE\',\n    });\n    if (!response.ok) throw new Error(\'Failed to delete alert\');\n  }\n\n  async generateReport(portfolioId: string, reportType: ReportType, filters?: ReportFilters): Promise<Report> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${portfolioId}/reports`, {\n      method: \'POST\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify({ type: reportType, filters }),\n    });\n    if (!response.ok) throw new Error(\'Failed to generate report\');\n    return response.json();\n  }\n\n  async exportData(portfolioId: string, format: \'csv\' | \'json\' | \'pdf\', filters?: ExportFilters): Promise<Blob> {\n    const params = new URLSearchParams({ format });\n    if (filters) {\n      Object.entries(filters).forEach(([key, value]) => {\n        if (value !== undefined) {\n          if (Array.isArray(value)) {\n            value.forEach(v => params.append(key, v));\n          } else {\n            params.append(key, String(value));\n          }\n        }\n      });\n    }\n\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${portfolioId}/export?${params}`);\n    if (!response.ok) throw new Error(\'Failed to export data\');\n    return response.blob();\n  }\n\n  async getBudgets(portfolioId: string): Promise<Budget[]> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${portfolioId}/budgets`);\n    if (!response.ok) throw new Error(\'Failed to get budgets\');\n    return response.json();\n  }\n\n  async createBudget(portfolioId: string, budget: Omit<Budget, \'id\' | \'createdAt\'>): Promise<Budget> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/portfolios/${portfolioId}/budgets`, {\n      method: \'POST\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify(budget),\n    });\n    if (!response.ok) throw new Error(\'Failed to create budget\');\n    return response.json();\n  }\n\n  async updateBudget(id: string, updates: Partial<Budget>): Promise<Budget> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/budgets/${id}`, {\n      method: \'PUT\',\n      headers: { \'Content-Type\': \'application/json\' },\n      body: JSON.stringify(updates),\n    });\n    if (!response.ok) throw new Error(\'Failed to update budget\');\n    return response.json();\n  }\n\n  async deleteBudget(id: string): Promise<void> {\n    const response = await fetch(`${this.baseUrl}/api/portfolio/budgets/${id}`, {\n      method: \'DELETE\',\n    });\n    if (!response.ok) throw new Error(\'Failed to delete budget\');\n  }\n\n  async getBudgetPerformance(budgetId: string, timeRange?: TimeRange): Promise<BudgetPerformance> {\n    const params = timeRange ? `?timeRange=${timeRange}` : \'\';\n    const response = await fetch(`${this.baseUrl}/api/portfolio/budgets/${budgetId}/performance${params}`);\n    if (!response.ok) throw new Error(\'Failed to get budget performance\');\n    return response.json();\n  }\n}\n\nexport const portfolioAggregatorService = new PortfolioAggregatorServiceImpl();\nexport const usePortfolioAggregatorService = () => portfolioAggregatorService;\n</create-file>\n</function_calls>'}