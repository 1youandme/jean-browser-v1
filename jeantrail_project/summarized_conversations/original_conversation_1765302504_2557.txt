{'role': 'assistant', 'content': '\n<function_calls>\n<create-file file_path="src/services/api.service.ts">\nimport { authService } from \'./auth.service\';\n\ninterface ApiResponse<T> {\n  data: T;\n  message?: string;\n  status: number;\n}\n\ninterface ApiError {\n  message: string;\n  status: number;\n  code?: string;\n  details?: any;\n}\n\nclass ApiService {\n  private readonly baseUrl = \'/api\';\n  private defaultHeaders: Record<string, string> = {\n    \'Content-Type\': \'application/json\',\n  };\n\n  // Get auth token from store or localStorage\n  private getAuthToken(): string | null {\n    // Try to get from localStorage first\n    const token = localStorage.getItem(\'auth-token\');\n    if (token) return token;\n\n    // Try to get from Zustand store (if accessible)\n    // This would need to be implemented based on your store setup\n    return null;\n  }\n\n  // Set up request headers\n  private getHeaders(): Record<string, string> {\n    const token = this.getAuthToken();\n    return {\n      ...this.defaultHeaders,\n      ...(token && { Authorization: `Bearer ${token}` }),\n    };\n  }\n\n  // Handle API errors\n  private async handleError(response: Response): Promise<ApiError> {\n    let error: ApiError;\n    \n    try {\n      const errorData = await response.json();\n      error = {\n        message: errorData.message || \'An error occurred\',\n        status: response.status,\n        code: errorData.code,\n        details: errorData.details,\n      };\n    } catch {\n      error = {\n        message: response.statusText || \'An error occurred\',\n        status: response.status,\n      };\n    }\n\n    // Handle authentication errors\n    if (response.status === 401) {\n      const token = this.getAuthToken();\n      if (token && authService.isTokenExpired(token)) {\n        // Token expired, try to refresh\n        try {\n          const refreshToken = localStorage.getItem(\'refresh-token\');\n          if (refreshToken) {\n            const { token: newToken } = await authService.refreshToken(refreshToken);\n            localStorage.setItem(\'auth-token\', newToken);\n            // Don\'t throw here, let the calling code retry the request\n          }\n        } catch {\n          // Refresh failed, clear tokens and redirect to login\n          localStorage.removeItem(\'auth-token\');\n          localStorage.removeItem(\'refresh-token\');\n          window.location.href = \'/login\';\n        }\n      }\n    }\n\n    throw error;\n  }\n\n  // Generic request method\n  private async request<T>(\n    endpoint: string,\n    options: RequestInit = {}\n  ): Promise<ApiResponse<T>> {\n    const url = `${this.baseUrl}${endpoint}`;\n    \n    const config: RequestInit = {\n      ...options,\n      headers: {\n        ...this.getHeaders(),\n        ...options.headers,\n      },\n    };\n\n    try {\n      const response = await fetch(url, config);\n\n      if (!response.ok) {\n        await this.handleError(response);\n      }\n\n      const data = await response.json();\n      return {\n        data,\n        status: response.status,\n      };\n    } catch (error) {\n      if (error instanceof Error) {\n        throw {\n          message: error.message,\n          status: 0,\n        };\n      }\n      throw error;\n    }\n  }\n\n  // HTTP methods\n  async get<T>(endpoint: string, params?: Record<string, any>): Promise<ApiResponse<T>> {\n    let url = endpoint;\n    if (params) {\n      const searchParams = new URLSearchParams(params);\n      url += `?${searchParams.toString()}`;\n    }\n    \n    return this.request<T>(url, { method: \'GET\' });\n  }\n\n  async post<T>(endpoint: string, data?: any): Promise<ApiResponse<T>> {\n    return this.request<T>(endpoint, {\n      method: \'POST\',\n      body: data ? JSON.stringify(data) : undefined,\n    });\n  }\n\n  async put<T>(endpoint: string, data?: any): Promise<ApiResponse<T>> {\n    return this.request<T>(endpoint, {\n      method: \'PUT\',\n      body: data ? JSON.stringify(data) : undefined,\n    });\n  }\n\n  async patch<T>(endpoint: string, data?: any): Promise<ApiResponse<T>> {\n    return this.request<T>(endpoint, {\n      method: \'PATCH\',\n      body: data ? JSON.stringify(data) : undefined,\n    });\n  }\n\n  async delete<T>(endpoint: string): Promise<ApiResponse<T>> {\n    return this.request<T>(endpoint, { method: \'DELETE\' });\n  }\n\n  // File upload\n  async upload<T>(\n    endpoint: string,\n    file: File,\n    additionalData?: Record<string, any>\n  ): Promise<ApiResponse<T>> {\n    const formData = new FormData();\n    formData.append(\'file\', file);\n    \n    if (additionalData) {\n      Object.entries(additionalData).forEach(([key, value]) => {\n        formData.append(key, value);\n      });\n    }\n\n    const url = `${this.baseUrl}${endpoint}`;\n    const token = this.getAuthToken();\n\n    try {\n      const response = await fetch(url, {\n        method: \'POST\',\n        body: formData,\n        headers: token ? { Authorization: `Bearer ${token}` } : {},\n      });\n\n      if (!response.ok) {\n        await this.handleError(response);\n      }\n\n      const data = await response.json();\n      return {\n        data,\n        status: response.status,\n      };\n    } catch (error) {\n      if (error instanceof Error) {\n        throw {\n          message: error.message,\n          status: 0,\n        };\n      }\n      throw error;\n    }\n  }\n\n  // File download\n  async download(endpoint: string, filename?: string): Promise<void> {\n    const url = `${this.baseUrl}${endpoint}`;\n    const token = this.getAuthToken();\n\n    try {\n      const response = await fetch(url, {\n        headers: token ? { Authorization: `Bearer ${token}` } : {},\n      });\n\n      if (!response.ok) {\n        await this.handleError(response);\n      }\n\n      const blob = await response.blob();\n      const downloadUrl = window.URL.createObjectURL(blob);\n      const a = document.createElement(\'a\');\n      a.href = downloadUrl;\n      a.download = filename || \'download\';\n      document.body.appendChild(a);\n      a.click();\n      document.body.removeChild(a);\n      window.URL.revokeObjectURL(downloadUrl);\n    } catch (error) {\n      if (error instanceof Error) {\n        throw {\n          message: error.message,\n          status: 0,\n        };\n      }\n      throw error;\n    }\n  }\n\n  // Streaming request for AI responses\n  async *stream<T>(endpoint: string, data?: any): AsyncGenerator<T> {\n    const url = `${this.baseUrl}${endpoint}`;\n    const token = this.getAuthToken();\n\n    try {\n      const response = await fetch(url, {\n        method: \'POST\',\n        headers: {\n          \'Content-Type\': \'application/json\',\n          ...(token && { Authorization: `Bearer ${token}` }),\n        },\n        body: data ? JSON.stringify(data) : undefined,\n      });\n\n      if (!response.ok) {\n        await this.handleError(response);\n      }\n\n      const reader = response.body?.getReader();\n      const decoder = new TextDecoder();\n\n      if (!reader) {\n        throw new Error(\'Response body is not readable\');\n      }\n\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        const chunk = decoder.decode(value);\n        const lines = chunk.split(\'\\n\');\n\n        for (const line of lines) {\n          if (line.startsWith(\'data: \')) {\n            const data = line.slice(6);\n            if (data === \'[DONE]\') return;\n            \n            try {\n              const parsed = JSON.parse(data);\n              yield parsed;\n            } catch {\n              // Skip invalid JSON lines\n            }\n          }\n        }\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        throw {\n          message: error.message,\n          status: 0,\n        };\n      }\n      throw error;\n    }\n  }\n\n  // WebSocket connection\n  createWebSocket(endpoint: string): WebSocket {\n    const protocol = window.location.protocol === \'https:\' ? \'wss:\' : \'ws:\';\n    const url = `${protocol}//${window.location.host}${this.baseUrl}${endpoint}`;\n    const token = this.getAuthToken();\n    \n    const wsUrl = token ? `${url}?token=${token}` : url;\n    return new WebSocket(wsUrl);\n  }\n\n  // Health check\n  async healthCheck(): Promise<ApiResponse<{ status: string; timestamp: string }>> {\n    return this.get(\'/health\');\n  }\n\n  // Set base URL (useful for different environments)\n  setBaseUrl(url: string): void {\n    // This would need to be implemented to update the base URL\n    // For now, we assume the base URL is always \'/api\'\n  }\n\n  // Set default headers\n  setDefaultHeaders(headers: Record<string, string>): void {\n    this.defaultHeaders = { ...this.defaultHeaders, ...headers };\n  }\n\n  // Clear auth tokens (for logout)\n  clearAuth(): void {\n    localStorage.removeItem(\'auth-token\');\n    localStorage.removeItem(\'refresh-token\');\n  }\n}\n\nexport const apiService = new ApiService();\n\n// Export typed API methods for specific endpoints\nexport const authAPI = {\n  login: (credentials: any) => apiService.post(\'/auth/login\', credentials),\n  register: (userData: any) => apiService.post(\'/auth/register\', userData),\n  logout: () => apiService.post(\'/auth/logout\'),\n  refresh: (refreshToken: string) => apiService.post(\'/auth/refresh\', { refreshToken }),\n  me: () => apiService.get(\'/auth/me\'),\n};\n\nexport const projectsAPI = {\n  getAll: () => apiService.get(\'/projects\'),\n  getById: (id: string) => apiService.get(`/projects/${id}`),\n  create: (data: any) => apiService.post(\'/projects\', data),\n  update: (id: string, data: any) => apiService.put(`/projects/${id}`, data),\n  delete: (id: string) => apiService.delete(`/projects/${id}`),\n};\n\nexport const aiAPI = {\n  services: () => apiService.get(\'/ai/services\'),\n  process: (data: any) => apiService.post(\'/ai/process\', data),\n  generateImage: (data: any) => apiService.post(\'/ai/generate-image\', data),\n  transcribe: (file: File) => apiService.upload(\'/ai/transcribe\', file),\n  synthesize: (data: any) => apiService.post(\'/ai/synthesize\', data),\n};\n\nexport const dashboardAPI = {\n  services: () => apiService.get(\'/dashboard/services\'),\n  metrics: () => apiService.get(\'/dashboard/metrics\'),\n  tasks: () => apiService.get(\'/dashboard/tasks\'),\n  toggleService: (name: string) => apiService.post(`/dashboard/services/${name}/toggle`),\n  restartService: (name: string) => apiService.post(`/dashboard/services/${name}/restart`),\n  cancelTask: (id: string) => apiService.post(`/dashboard/tasks/${id}/cancel`),\n};\n</create-file>\n</function_calls>'}